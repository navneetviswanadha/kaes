#BlueJ class context
comment0.target=KinTermMap
comment0.text=\ HISTORY\r\n\ 2/12/01\ DR\ replaced\ "if\ ((g\=generators.indexOf(gen))\ \=\=\ -1)\ {throw\ new\ KintermMapException\ .....}"\r\n\ by\ "if\ (\ (\ g\ \=\ \ generators.indexOf(gen)\ )\ \=\=\ -1)\ return\ "\ ";"\r\n\ in\ procedure\:\ public\ String\ generatorToMapgen(String\ gen)\r\n\ 2/13\ DR\ added\ "if\ (femaleGen\ \=\=\ null)\ continue;"\ and\ "if\ (maleGen\ \=\=\ null)\ continue;"\r\n\ to\ the\ procedure\:\ "public\ int\ matchTermsAndSexes"\r\n\ theGen\ added\ as\ an\ argument\ to\ the\ procedure\ "matchTermsAndSexes"\ to\ allow\ printing\ out\ the\ algebra\ generator\ in\ the\ message.\r\n\ 2/14\ DR\ add\ the\ null\ test\ (\ tki\ \!\=\ null)to\ the\ procedure\t"__addToAlgebraKin"\r\n\ 2/23\ DR\ added\ procedure\ getMatchingFocalTerm\ (String\ fe);\ added\ fe\ to\ argument\ of\ _addToAlgebraKin;\r\n\ procedure\ used\ in\ addToAlgebraKin\r\n\ replaced\ 'currentTerm\ \=\ "Self";'\ with\ currentTerm\ \=\ getMatchingFocalTerm(fe);\r\n\ 2/24\ DR\ removed\ messages\ for\ Male\ Gen\ and\ Female\ Gen\ in\ matchTermsAndSexes\r\n\ 3/11\ DR\ modified\ the\ procedures\ associateAlgebraGeneratorsWithKinshipGenerators\ and\ matchTermsAndSexes\ to\ allow\ for\ algebra\r\n\ elements\ with\ the\ sex\ attribute\ set\ rather\ than\ using\ a\ sex\ generator\ to\ denote\ sex\r\n\ 3/12\ DR\ modified\ __addToAlgebraKin\ so\ that\ it\ works\ with\ sex\ attributes\ and\ not\ just\ sex\ generators\r\n\ 7/01\ DR\ replaced\ "I"\ by\ "isIdentityElement()"\ in\ procedure\ __addToAlgebraKin\r\n\ 11/11\ DR\ added\ criterion\ (ret.indexOf(sexed)\ \=\=\ -1)\ to\ getSexGenProducts\r\n\ 11/21\ DR\ modified\ __addToAlgebraKin\ to\ work\ with\ equivalent\ elements\ of\ form\ abc&def\r\n\ 5/27\ DR\ separated\ part\ of\ TestIsomorphism\ out\ as\ a\ new\ procedure,\ linkAlgebraWithKinTermMap(CayleyTable\ x),\r\n\ in\ order\ to\ reference\ the\ first\ part\ of\ without\ calling\ TestIsomorphism\r\n\ 8/1\ DR\ rewrote\ testIsomorphism\ to\ return\ ListVector\ of\ non-matching\ terms\ and\ algebra\r\n\ elements\r\n\ 8/22\ DR\ modified\ associateAlgebraGeneratorsWithKinshipGenerators\ to\ run\ only\ if\ the\r\n\ generating\ \=\ null;\ corrected\ the\ logic\ of\ the\ procedure\ so\ that\ a\ set\ of\ kin\ term\r\n\ generators\ (UP,\ DOWN,\ SPOUSE)\ are\ compared\ against\ a\ set\ of\ algebra\ generators;\ added\r\n\ some\ error\ messages\r\n\ 8/28\ corrected\ problem\ in\ _addToAlgebraKin\ with\ linking\ sex\ generator\ with\ generator\r\n\ when\ computing\ kin\ term\ corresponding\ to\ algebra\ path;\ added\ procedure\ putInHashTable\r\n\ to\ handle\ problem\ with\ multiple\ calls\ to\ put\ in\ _addToAlgebraKin\ due\ to\ some\ trial\ paths\r\n\ not\ corresponding\ to\ a\ kin\ term\r\n\ 9/1\ DR\ modified\ __addToAlgebraKin\ to\ handle\ equivalent\ algebra\ elements\ A&B;\ if\r\n\ A&B\ links\ to\ K\ via\ generator\ G,\ then\ construct\ link\ from\ A\ or\ from\ B\ to\ K\ via\ G\ in\r\n\ accordance\ with\ sex\ of\ A,\ B\ and\ G\r\n\ 1/26\ DR\ modified\ buildKinTermMap\ to\ handle\ case\ where\ generators\ are\ covered\ but\r\n\ covering\ term\ is\ not\ a\ generator\r\n
comment1.params=
comment1.target=StringVector\ getGenerators()
comment10.params=mapkey\ mappedTerm
comment10.target=void\ mapTerm(java.lang.String,\ java.lang.String)
comment10.text=\ makes\ an\ entry\ and\ definition\ for\ a\ kin\ term\r\n\ @param\ mapKey\ starting\ kin\ term\ SPACE\ generating\ term\ SPACE\ sex\ marker\r\n\ @param\ mappedTerm\ kin\ term\ associated\ with\ mapKey\r\n
comment11.params=mapTerm\ generatingTerm\ sex
comment11.target=java.lang.String\ getTerm(java.lang.String,\ java.lang.String,\ java.lang.String)
comment11.text=\ returns\ a\ kin\ term\ \ based\ on\ keys\r\n\ @param\ mapTerm\ starting\ kin\ term\r\n\ @param\ generatingTerm\ generating\ term\ relative\ to\ mapTerm\r\n\ @param\ sex\ sex\ marker\ associated\ with\ mappedTerm\r\n\ @return\ kin\ term\ associated\ with\ mapTerm\ and\ generatingTerm\ with\ sex\ marker\ sex\r\n
comment12.params=mapTerm\ generatingTerm
comment12.target=java.lang.String\ getTerm(java.lang.String,\ java.lang.String)
comment12.text=\ returns\ a\ kin\ term\ \ based\ on\ key\r\n\ @param\ mapTerm\ starting\ kin\ term\r\n\ @param\ generatingTerm\ generating\ term\ relative\ to\ mapTerm\r\n\ @return\ kin\ term\ associated\ with\ mapTerm\ and\ generatingTerm,\ assuming\ neuter\r\n
comment13.params=mapTerm
comment13.target=java.lang.String\ getTerm(java.lang.String)
comment13.text=\ returns\ a\ kin\ term\ \ based\ on\ key\r\n\ @param\ mapKey\ starting\ kin\ term\ SPACE\ generating\ term\ SPACE\ sex\ marker\r\n\ @return\ kin\ term\ associated\ with\ mapKey\r\n
comment14.params=gen
comment14.target=java.lang.String\ generatorToMapgen(java.lang.String)
comment14.text=\ translates\ algebra\ generator\ name\ to\ kin\ term\ map\ generator\ name\r\n\ @param\ gen\ algebra\ generator\ name\r\n\ @return\ kin\ term\ map\ generator\ name\ associate\ with\ algebra\ generator\ name\r\n
comment15.params=gen
comment15.target=StringVector\ generatorToGenderedGenerators(java.lang.String)
comment15.text=\ translates\ algebra\ generator\ name\ to\ kin\ term\ map\ generator\ name\r\n\ @param\ gen\ algebra\ generator\ name\r\n\ @return\ kin\ term\ map\ generator\ name\ associated\ with\ algebra\ generator\ name\r\n
comment16.params=gen
comment16.target=java.lang.String\ mapgenToGenerator(java.lang.String)
comment16.text=\ translates\ kin\ term\ map\ generator\ name\ to\ algebra\ generator\ name\r\n\ @param\ gen\ \ kin\ term\ map\ generator\ name\r\n\ @return\ algebra\ generator\ name\ associate\ with\ kin\ term\ map\ generator\ name\r\n
comment17.params=generator\ generatingTerm
comment17.target=void\ associateGenerators(java.lang.String,\ java.lang.String)
comment17.text=\ associate\ algebra\ generator\ name\ \ with\ kin\ term\ map\ generator\ name\r\n\ @param\ generatingTerm\ algebra\ generator\ name\r\n\ @param\ generator\ \ kin\ term\ map\ generator\ name\r\n
comment18.params=av
comment18.target=java.lang.String\ trace(AlgebraSymbolVector)
comment19.params=av
comment19.target=java.util.Vector\ traceMapPath(AlgebraSymbolVector)
comment2.params=
comment2.target=StringVector\ getGeneratingTerms()
comment20.params=fe
comment20.target=java.lang.String\ getMatchingFocalTerm(java.lang.String)
comment20.text=\tpublic\ boolean\ addToAlgebraKinx(AlgebraPath\ ap)\ {\r\n\t\tString\ currentTerm;\r\n\t\tboolean\ ret\ \=true;\r\n\t\tboolean\ isEtc\ \=\ false;\r\n\t\tAlgebraSymbol\ lastGenerator\ \=\ null;\r\n\t\t//Debug.on(-6);\r\n\t\tDebug.prout(6,"addToAlgKin\:\ this\="+this);\r\nDebug.prout(6,"addToAlgKin\:\ ap\="+ap);\r\n\r\n\t\tAlgebraSymbolVector\ av\ \=\ ap.getReducedProductPath();\r\n\t\t//\ set\ current\ term\ to\ focal\ term\ ..\ for\ now,\ rethink\ later\ when\ more\ than\ one\ focal\ term\r\nDebug.prout(6,"addToAlgKin\:\ av\="+av);\r\n\t\tAlgebraSymbolVector\ focalElements\ \=\ Algebra.getCurrent().getFocalElements();\r\n\t\tif\ (focalElements.size()\ \=\=\ 0)\ return\ false;\r\n\t\tcurrentTerm\ \=\ focalElements.getSymbol(0).getValue();\ //\ kludge...only\ looks\ at\ first\ +++++\r\n\t\tcurrentTerm\ \=\ generatorToMapgen(currentTerm);\r\n\r\n\t\t//currentTerm\ \=\ generatorToMapgen(av.getSymbol(0).getValue());\ //\ cludge\ since\ no\ productions\ from\ self\r\n\r\n\t\tfor\ (int\ i\=0;i<av.size();i++)\ {\r\nDebug.prout(6,"addToAlgKin\:\ Probe\ a");\r\n\t\t\tAlgebraSymbol\ a\ \=\ av.getSymbol(i);\r\nDebug.prout(6,"addToAlgKin\:\ a\="+a);\r\n\r\n\t\t\tif\ (a.getValue().equals\ ("0"))\ {\r\n\t\t\t\tcurrentTerm\ \=\ "<Undefined>";\r\nDebug.prout(6,"addToAlgKin\:\ <Undefined>\="+a);\r\n//System.out.println("addToAlgKin\:\ <Undefined>\="+a);\r\n\t\t\t\tret\ \=\ false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif\ (a.getValue().equals\ ("I"))\ {\r\n\t\t\t\tcurrentTerm\ \=\ "Self";\ //\ derive\ from\ TransferKinInfo\r\nDebug.prout(6,"addToAlgKin\:\ Self\="+a);\r\n\t\t\t\tret\ \=\ true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tString\ []\ components\ \=\ Algebra.getCurrent().theKludge.algebraSymbolToComponents(a);\r\nDebug.prout(6,"currentterm\ in\:\ "\ +\ currentTerm);\r\nDebug.prout(6,"addToAlgKin\:\ components\="+components[0]+","+components[1]+"\ ");\r\nDebug.prout(6,"addToAlgKin\:\ generatorToMapgen\="+generatorToMapgen(components[0]));\r\n\r\n\t\t\tcurrentTerm\ \=\ getTerm(currentTerm,\ generatorToMapgen(components[0]),components[1]);\r\nDebug.prout(6,"currentterm\ out\:\ "\ +\ currentTerm);\r\n\t\t\tif\ (\!currentTerm.equals\ ("<Undefined>"))\ {\r\n\r\n\r\n\t\t\t\tTransferKinInfo\ tki\ \=\ getKintabTerm(currentTerm);\r\nDebug.prout(6,"addToAlgKin\:\ TransferKinInfo\="+tki);\r\n\r\n\t\t\t\tif\ (tki.isEtc())\ {\r\nDebug.prout(6,"addToAlgKin\:\ isEtc\="+a);\r\n\t\t\t\t\tlastGenerator\ \=\ a;\r\n\t\t\t\t\tisEtc\ \=\ true;\r\n\t\t\t\t}\ else\ {\r\n\t\t\t\t\tisEtc\ \=\ false;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif\ (isEtc\ &&\ a.equals(lastGenerator))\ {\r\nDebug.prout(6,"addToAlgKin\:\ etc+\="+a);\r\n\t\t\t\t\tcurrentTerm\="etc+";\ //\ possibly\ more\ later\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\nDebug.prout(6,"addToAlgKin\:\ <Undefined>\="+a);\r\n\r\n\t\t\t\tcurrentTerm\ \=\ "<Undefined>";\r\n\t\t\t\tret\ \=\ false;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\t\t\t\t\t\tDebug.prout(6,"at\ 7");\r\n\r\n\t\tif\ (\!currentTerm.equals("etc+"))\ algebraKinKeys.addElement(ap);\r\n\t\t\t\t\t\t\t\t\tDebug.prout(6,"at\ 8");\r\n\r\n\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\treturn\ ret;\r\n\t}\r\n
comment21.params=key\ currentTerm
comment21.target=void\ putInHashTable(java.lang.String,\ java.lang.String)
comment22.params=ap
comment22.target=boolean\ addToAlgebraKin(AlgebraPath)
comment23.params=ap\ ndx\ fe\ currentTerm\ isEtc\ lastGenerator
comment23.target=boolean\ __addToAlgebraKin(AlgebraPath,\ int,\ java.lang.String,\ java.lang.String,\ boolean,\ AlgebraSymbol)
comment24.params=ap\ term
comment24.target=java.lang.String\ _unpackTerm(AlgebraPath,\ java.lang.String)
comment25.params=aMap
comment25.target=StringVector\ compareCayleyTables(CayleyEntity)
comment25.text=\r\n\tpublic\ void\ __addToAlgebraKinX(AlgebraPath\ ap,\ int\ ndx,\ String\ fe,String\ currentTerm,\ boolean\ isEtc,\ AlgebraSymbol\ lastGenerator)\ {\r\n\r\n\t\tif\ (ndx\ >\=\ ap.getReducedProductPath().size())\ {\r\n\t\t\tTransferKinInfo\ tki\ \=\ getKintabTerm(currentTerm);\r\nSystem.out.println("tki\="+tki+"\ \=currentTerm\ "+currentTerm+"getsex\="+tki.getSex());\r\n\t\t\t//if\ (tki.getSex().equals("N"))\ {\r\n\t\t\t\tif\ (\!currentTerm.equals("etc+"))\ algebraKinKeys.addUnique(ap);\r\n\t\t\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\t\t//}\r\n\t\t\treturn;\ //\ check\ for\ etc.\ eg\ algebra\ too\ small\ for\ ktm\r\n\t\t}\r\n\r\n\t\tAlgebraSymbol\ a\ \=\ ap.getReducedProductPath().getSymbol(ndx);\r\n//\tSystem.out.println("AP.REDUCED+"+a);\r\n\t\t//if\ (a.getSex().equals("F"))\ {\r\n\t\tif\ (a.getValue().equals("F"))\ {\r\n\t\t\tTransferKinInfo\ tki\ \=\ getKintabTerm(currentTerm);\r\n\t\t\tif\ ((\ tki\ \!\=\ null)\ &&\ (tki.getSex().equals("F")))\ {\r\n\t\t\t\tif\ (\!currentTerm.equals("etc+"))\ algebraKinKeys.addUnique(ap);\r\n\t\t\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t//\tif\ (a.getSex().equals("M"))\ {\r\n\t\tif\ (a.getValue().equals("M"))\ {\r\n\t\t\tTransferKinInfo\ tki\ \=\ getKintabTerm(currentTerm);\r\n\t\t\tif\ ((tki\ \!\=\ null)\ &&\ ((tki.getSex().equals("M"))\ ||\ (tki.getSex().equals("N"))))\ {\r\n\t\t\t\tif\ (\!currentTerm.equals("etc+"))\ algebraKinKeys.addUnique(ap);\r\n\t\t\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif\ (a.getValue().equals\ ("0"))\ {\r\n\t\t\tcurrentTerm\ \=\ "<Undefined>";\r\n\t\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\t\treturn;\r\n\t\t}\ else\ if\ (a.getValue().equals\ ("I"))\ {\r\n\t\ \ \ \ \ \ \ \ currentTerm\ \=\ getMatchingFocalTerm(fe);\r\n\t\t\t//currentTerm\ \=\ "Self";\ //\ derive\ from\ TransferKinInfo\r\n\t\t\tif\ (\!currentTerm.equals("etc+"))\ algebraKinKeys.addUnique(ap);\r\n\t\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tStringVector\ a2k\ \=\ generatorToGenderedGenerators(a.toString());\r\n//System.out.println("XXXXX\ a2k\="+a2k);\r\n//System.out.println("XXX\ Generators\="+generators);\r\n\t\tString\ xcurrentTerm\=currentTerm;\r\n\t\tboolean\ xisEtc\=isEtc;\r\n\t\tAlgebraSymbol\ xlastGenerator\=lastGenerator;\r\n\t\tfor(int\ i\=0;i<a2k.size();i++)\ {\r\n\t\t\tcurrentTerm\ \=\ xcurrentTerm;\ isEtc\ \=\ xisEtc;\ lastGenerator\=xlastGenerator;\r\n\t\t\tString\ gkin,\ gsex\="N",\ gterm\=a2k.getSymbol(i);\r\n\t\t\tif\ (gterm.length()\ >\ 1)\ {\r\n\t\t\t\tgsex\ \=\ a2k.getSymbol(i).substring(0,1);\r\n\t\t\t\tgkin\ \=\ a2k.getSymbol(i).substring(1);\r\n\t\t\t}\r\n\t\t\tgkin\ \=\ gterm;//gsex\=\ "M";\r\n\t\t\tString\ oldCur\ \=\ currentTerm;\r\n\t\t\tcurrentTerm\ \=\ getTerm(currentTerm,\ generatorToMapgen(gterm),gsex);\r\n//System.out.println("XYXYX\ currentTerm\="+currentTerm);\r\n\t\t\tif\ (currentTerm.equals("<Undefined>")\ &&\ \!gsex.equals("N"))\r\n\t\t\t\tcurrentTerm\ \=\ getTerm(oldCur,\ generatorToMapgen(gterm),"N");\r\n\t\t\t//if\ (currentTerm.length()\ <\ 3)\r\n\t\t\t\t//System.out.println("\=\=\=\=\=\=\=>currentterm"+oldCur+"\ result\="+currentTerm+"\ gkin\ "+gkin+"\ gsex\=\ "+gsex+"\ term\="+generatorToMapgen(gterm));\r\n\t\t\tif\ (\!currentTerm.equals("<Undefined>"))\ {\r\n\t\t\t\tTransferKinInfo\ tki\ \=\ getKintabTerm(currentTerm);\r\n\t\t\t\tif\ (tki.isEtc())\ {\r\n\t\t\t\t\tlastGenerator\ \=\ a;\r\n\t\t\t\t\tisEtc\ \=\ true;\r\n\t\t\t\t}\ else\ {\r\n\t\t\t\t\tisEtc\ \=\ false;\r\n\t\t\t\t}\r\n\t\t\t\tif\ (ndx+1\ <\ ap.getReducedProductPath().size())\ {\r\n\t\t\t\t\t__addToAlgebraKin(ap,ndx+1,fe,currentTerm,isEtc,lastGenerator);\r\n\t\t\t\t}\ else\ {\r\n\t\t\t\t\t//if\ (currentTerm.equals("etc+"))\ algebraKin.put(ap.toString(),currentTerm);\ else\r\n\t\t\t\t\t//\ if\ (tki.getSex().equals("N"))\ {\r\n\t\t\t\t\t\ //if\ (tki.getSex().equals("M"))\ {\r\n\t\t\t\t\t\tif\ (\!currentTerm.equals("etc+"))\ algebraKinKeys.addUnique(ap);\r\n\t\t\t\t\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\t\t\t\t//}\r\nSystem.out.println("tki\="+tki+"\=currentTerm\ "+currentTerm+"getsex\="+tki.getSex());\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif\ (isEtc\ &&\ a.equals(lastGenerator))\ {\r\n\t\t\t\t\tcurrentTerm\="etc+";\ //\ possibly\ more\ later\r\n\t\t\t\t}\r\n\r\n\t\t\t\talgebraKin.put(ap.toString(),currentTerm);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n
comment26.params=
comment26.target=java.lang.String\ toString()
comment27.params=x
comment27.target=CayleyTable\ linkAlgebraWithKinTermMap(CayleyTable)
comment27.text=\tpublic\ boolean\ testIsomorphismX()\ {\r\n\t\tCayleyTable\ x\ \=\ new\ CayleyTable(Algebra.getCurrent().getElements());\r\n\t\tx.generateProducts();\r\n\t\treturn\ testIsomorphismX(x);\r\n}
comment28.params=x\ misfits
comment28.target=CayleyTable\ linkAlgebraWithKinTermMap(CayleyTable,\ StringVector)
comment29.params=misfits
comment29.target=ListVector\ testIsomorphism(StringVector)
comment29.text=\r\n\t\tStringVector\ testAgainstMe\ \=\ x.compareCayleyTables(this);\r\n//System.out.println("testIsomorphism\:\ +_+_+_+_+_+_+_+_+_+_+\ Compared\ this\ against\ Cayley\ products");\r\n\t\tStringVector\ testAgainstIt\ \=\ compareCayleyTables(x);\r\n//System.out.println("testIsomorphism\:\ +_+_+_+_+_+_+_+_+_+_+\ Compared\ \ Cayley\ products\ against\ this\ ");\r\n\r\n\r\n\r\n\t\tif\ (\ testAgainstMe.size()\ \=\=\ 0\ &&\ testAgainstIt.size()\ \=\=\ 0)\ {\r\n\t\t\t//System.out.println("Isomorphic\!\ testAgainstMe\="+testAgainstMe+"\ testAgainstIt\="+testAgainstIt);\r\n\t\t\tSystem.out.println("Isomorphic\!\ ");\r\n\t\t\treturn\ true;\r\n\t\t}\ else\ if\ (testAgainstMe.size()\ \=\=\ 0\ )\ {\r\n\t\t\tSystem.out.println("IHalf-isomorphic\ Me\!\ ");\r\n\t\t\t//System.out.println("Half-isomorphic\ Me\!\ testAgainstMe\="+testAgainstMe+"\ testAgainstIt\="+testAgainstIt);\r\n\t\t\treturn\ false;\r\n\t\t}\ else\ if\ (testAgainstIt.size()\ \=\=\ 0\ ){\r\n\t\t\tSystem.out.println("Half-isomorphic\ It\!\ testAgainstMe\="+testAgainstMe+"\ testAgainstIt\="+testAgainstIt);\r\n\t\t\t//System.out.println("IHalf-isomorphic\ It\!\ ");\r\n\t\t\treturn\ false;\r\n\t\t}\ else\ {\r\n\t\t//\tSystem.out.println("Not\ isomorphic\ Me\!\ ");\r\n\t\t//\tSystem.out.println("Not\ Isomorphic\!\ testAgainstMe\="+testAgainstMe);\r\n\t\t\tSystem.out.println("Not\ Isomorphic\!\ testAgainstMe\="+testAgainstMe+"\ testAgainstIt\="+testAgainstIt);\r\n\t\t\treturn\ false;\r\n\t\t}\r\n//undo\ all\ ssytmeoou\r\n\r\n}
comment3.params=
comment3.target=KinTermMap()
comment3.text=\ creates\ a\ new\ kin\ term\ map\ with\ name\ Map\ +\ sequence\ number\r\n\ @see\ \#mapno\r\n
comment30.params=x\ misfits
comment30.target=ListVector\ testIsomorphism(CayleyTable,\ StringVector)
comment31.params=a
comment31.target=StringVector\ mapAlgebraProductsToKinshipTerms(AlgebraPathVector)
comment31.text=\tpublic\ StringVector\ mapAlgebraProductsToKinshipTermsXX(AlgebraPathVector\ a)\ {\r\n\t\talgebraKin.clear();\r\n\t\tStringVector\ ret\ \=\ new\ StringVector();\r\n\t\tfor(int\ i\=0;i<a.size();i++)\ {\r\n\t\t\ \ \ \ AlgebraPath\ ap\ \=\ new\ AlgebraPath();\r\n\t\t\ \ \ \ ap\ \=\ (AlgebraPath)a.getSymbol(i).clone();\r\n\t\t\ \ \ //\ System.out.println("\ the\ oath\ "+\ a+\ "\ symbol\ "+a.getSymbol(i)+"\ i\ "+i);\r\n\t\t\tif\ (\!addToAlgebraKin(ap.getEquivalentPathLeft()))\ {\r\n\t\t\t\tret.addElement(ap.getEquivalentPathLeft().toString());\r\n\t\t\t//if\ (\!addToAlgebraKin(a.getSymbol(i).getEquivalentPathLeft()))\ {\r\n\t\t\t//\tret.addElement(a.getSymbol(i).getEquivalentPathLeft().toString());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn\ ret;\r\n}
comment32.params=s
comment32.target=TransferKinInfo\ getKintabTerm(java.lang.String)
comment33.params=
comment33.target=void\ buildKinTermMap()
comment33.text=\ (re-)builds\ based\ on\ information\ in\ incoming\ TransferKinInfoVector\ structure\r\n
comment34.params=tk
comment34.target=void\ buildKinTermMap(TransferKinInfoVector)
comment34.text=\ (re-)builds\ based\ on\ information\ in\ incoming\ TransferKinInfoVector\ structure\r\n\ @param\ tk\ the\ kinship\ term\ info\r\n
comment35.params=term\ tk
comment35.target=boolean\ coveredGenerators(java.lang.String,\ TransferKinInfoVector)
comment36.params=gen\ sexes\ prods
comment36.target=AlgebraPathVector\ getGenSexProducts(AlgebraSymbol,\ AlgebraSymbolVector,\ AlgebraPathVector)
comment36.text=\ return\ sex\ marked\ versions\ of\ generator\r\n\ @gen\ generator\r\n\ @sexes\ sex\ markers\r\n\ @prods\ algebra\ elements\r\n\ @ret\ sex\ marked\ versions\ of\ generator\ based\ on\ sexes\r\n
comment37.params=asv\ sexes\ tkv\ algproducts\ maleGen\ femaleGen\ arrow
comment37.target=int\ matchTermsAndSexes(AlgebraSymbolVector,\ AlgebraSymbolVector,\ TransferKinInfoVector,\ AlgebraPathVector,\ AlgebraSymbol,\ AlgebraSymbol,\ java.lang.String)
comment38.params=algproducts
comment38.target=boolean\ associateAlgebraGeneratorsWithKinshipGenerators(AlgebraPathVector)
comment39.params=algproducts
comment39.target=boolean\ associateTheAlgebraGeneratorsWithKinshipGenerators(AlgebraPathVector)
comment4.params=label
comment4.target=KinTermMap(java.lang.String)
comment4.text=\ creates\ a\ new\ kin\ term\ map\ with\ name\ label\r\n\ @param\ label\ the\ name\ of\ this\ kin\ term\ map\r\n
comment40.params=theKinTerms
comment40.target=void\ setTheKinTerms(TransferKinInfoVector)
comment41.params=
comment41.target=TransferKinInfoVector\ getTheKinTerms()
comment5.params=label\ m
comment5.target=KinTermMap(java.lang.String,\ TransferKinInfoVector)
comment5.text=\ creates\ a\ new\ kin\ term\ map\ with\ name\ label\r\n\ @param\ label\ the\ name\ of\ this\ kin\ term\ map\r\n\ @param\ Kin\ data\ to\ intialise\ to\r\n
comment6.params=m
comment6.target=KinTermMap(TransferKinInfoVector)
comment6.text=\ creates\ a\ new\ kin\ term\ map\ with\ name\ label\r\n\ @param\ label\ the\ name\ of\ this\ kin\ term\ map\r\n\ @param\ Kin\ data\ to\ intialise\ to\r\n
comment7.params=
comment7.target=void\ init()
comment7.text=\ override\ in\ subclasses\ to\ initialize\ the\ kinmap\r\n
comment8.params=key
comment8.target=KinTermMap\ getMap(java.lang.String)
comment8.text=\ returns\ a\ kin\ term\ map\ based\ on\ key\r\n\ @param\ key\ name\ of\ kin\ term\ map\ to\ retrieve\r\n
comment9.params=mapTerm\ generatingTerm\ sex\ mappedTerm
comment9.target=void\ mapTerm(java.lang.String,\ java.lang.String,\ java.lang.String,\ java.lang.String)
comment9.text=\ makes\ an\ entry\ and\ definition\ for\ a\ kin\ term\r\n\ @param\ mapTerm\ starting\ kin\ term\r\n\ @param\ generatingTerm\ generating\ term\ relative\ to\ mapTerm\r\n\ @param\ sex\ sex\ marker\ associated\ with\ mappedTerm\r\n\ @param\ mappedTerm\ kin\ term\ associated\ with\ mapTerm\ and\ generatingTerm\ with\ sex\ marker\ sex\r\n
numComments=42
