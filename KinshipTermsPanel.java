/*

	A basic extension of the java.awt.Frame class

 */



import java.awt.*;
import java.util.*;
import java.awt.event.*;

/* Revision History
* 31/10 MF Added saveKinDataInNewFile() method for saving under new name.
	if xout is set to file by load or save, will attempt to reuse this file.
* 1-8 MF Finalised adding buffered graphics to reduce flash and improve line
		drawing. Also changes to KintermEntry, which calls routines in this class.
* 21-8 MF Added Marching ants selection, line selection, term deletion and line deletion
* 15-10 MF Added better threading to elmimate some thread deadlocks
* 22-11 MF Adjustments to selection routines to improve responsiveness.
* 06/08 DR Changed collateral+, Collateral- to Collateral-, Collateral+ to make 
* Collateral+ = 3 (= LEFT) and Collateral- = 2 (= RIGHT)
*/


public class KinshipTermsPanel extends Panel implements KinTermEditor
{
	MarchingAnts mants = new MarchingAnts();


	public KinshipTermsPanel()
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setLayout(null);
		setSize(864,607);
		touchypanel = new java.awt.Panel();
		touchypanel.setLayout(null);
		touchypanel.setVisible(false);
		touchypanel.setBounds(9,524,249,62);
		add(touchypanel);
		etcCheckbox = new java.awt.Checkbox("Etc.");
		etcCheckbox.setVisible(false);
		etcCheckbox.setBounds(172,6,43,22);
		etcCheckbox.setFont(new Font("SansSerif", Font.PLAIN, 10));
		touchypanel.add(etcCheckbox);
		arrowSelect = new java.awt.Choice();
		arrowSelect.addItem("Ancestor");
		arrowSelect.addItem("Descendant");
		arrowSelect.addItem("Collateral-");//change from + to -
		arrowSelect.addItem("Collateral+");//changes from - to +
		arrowSelect.addItem("Spouse");
		try {
			arrowSelect.select(-1);
		}
		catch (IllegalArgumentException e) { }
		arrowSelect.setVisible(false);
		touchypanel.add(arrowSelect);
		arrowSelect.setBounds(152,32,93,31);
		arrowSelect.setFont(new Font("SansSerif", Font.PLAIN, 10));
		generatorCheckbox = new java.awt.Checkbox("Generator");
		generatorCheckbox.setBounds(80,32,67,31);
		generatorCheckbox.setFont(new Font("SansSerif", Font.PLAIN, 10));
		touchypanel.add(generatorCheckbox);
		sexChoice = new java.awt.Choice();
		sexChoice.addItem("Neutral");
		sexChoice.addItem("Female");
		sexChoice.addItem("Male");
		touchypanel.add(sexChoice);
		sexChoice.setBounds(3,32,71,31);
		sexChoice.setFont(new Font("SansSerif", Font.PLAIN, 10));
		button2 = new java.awt.Button();
		button2.setLabel("OK");
		button2.setBounds(215,4,29,25);
		touchypanel.add(button2);
		textField1 = new java.awt.TextField();
		textField1.setBounds(1,2,170,29);
		textField1.setFont(new Font("Serif", Font.PLAIN, 12));
		textField1.setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
		touchypanel.add(textField1);
		//touchypanel.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
		//}}
		//{{INIT_MENUS
		//}}
		//{{REGISTER_LISTENERS
		SymMouse aSymMouse = new SymMouse();
		button2.addMouseListener(aSymMouse);
		SymAction lSymAction = new SymAction();
		this.addMouseListener(aSymMouse);
		SymMouseMotion aSymMouseMotion = new SymMouseMotion();
		this.addMouseMotionListener(aSymMouseMotion);
		SymItem lSymItem = new SymItem();
		generatorCheckbox.addItemListener(lSymItem);
		etcCheckbox.addItemListener(lSymItem);
		SymComponent aSymComponent = new SymComponent();
		this.addComponentListener(aSymComponent);
		SymKey aSymKey = new SymKey();
		this.addKeyListener(aSymKey);
		//}}
		// arrowChoices1.validate();
	//	arrowPanel1.setOrientation(ArrowPanel.UP);
		// when
		addVariable("Sex");
		mants.initThread();
		// cFrame = ((KintermFrame)getParent()).cFrame;
		// updateKintable();
		// cFrame.add(cayleyPanel);
		// cFrame.show();
	}

	Panel cayleyPanel;
	KintermTextEntryForm cFrame=null;
	
	public void addVariable(String name) {
		theMaster.defineVariable(name);
		KintermEntry.kin.theVariables.masterRecord.defineVariable(name);
	}

	public KinshipTermsPanel(String title)
	{
		this();
	}

    /**
     * Shows or hides the component depending on the boolean flag b.
     * @param b  if true, show the component; otherwise, hide the component.
     * @see java.awt.Component#isVisible
     */

    public void setVisible(boolean b)
	{
		Debug.prout(4, "Hiding KinshipTermsPanel");
		if(b)
		{
			
			//setLocation(50, 50);
		} 
		if (cFrame != null) cFrame.setVisible(b);
		super.setVisible(b);
	}

	public void addNotify()
	{
	    // Record the size of the window prior to calling parents addNotify.
	    Dimension d = getSize();

		super.addNotify();
		if (fComponentsAdjusted)
			return;
		// Adjust components according to the insets
		setSize(insets().left + insets().right + d.width, insets().top + insets().bottom + d.height);
		Component components[] = getComponents();
		for (int i = 0; i < components.length; i++)
		{
			Point p = components[i].getLocation();
			p.translate(insets().left, insets().top);
			components[i].setLocation(p);
		}
		fComponentsAdjusted = true;
	}

    // Used for addNotify check.
	boolean fComponentsAdjusted = false;
	//{{DECLARE_CONTROLS
	java.awt.Panel touchypanel;
	java.awt.Checkbox etcCheckbox;
	java.awt.Choice arrowSelect;
	java.awt.Checkbox generatorCheckbox;
	java.awt.Choice sexChoice;
	java.awt.Button button2;
	java.awt.TextField textField1;
	//}}
	//{{DECLARE_MENUS
	//}}

	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosing(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == KinshipTermsPanel.this)
				KinshipTermsPanel_WindowClosing(event);
		}
	}

	void KinshipTermsPanel_WindowClosing(java.awt.event.WindowEvent event)
	{
		setVisible(false);		 // hide the Frame
		if (cFrame != null) cFrame.setVisible(false);
	}

	KintermEditObject kinTerm;
	public void editKinterm(KintermEditObject kte) {
		Panel ktt = touchypanel;
			//add(ktt);
			kinTerm = kte;
		if (kinTerm.getSex().equals("M")) {
		//	maleradioButton1.getCheckBoxGroup().getSelectedCheckBox().setState(false);
			sexChoice.select(2);
		} else if (kinTerm.getSex().equals("F")) {
			sexChoice.select(1);
		} else if (kinTerm.getSex().equals("N")) {
			sexChoice.select(0);
		}
		textField1.setText(kinTerm.getTheTerm());
		generatorCheckbox.setState(kte.isGenerating());
		arrowSelect.setVisible(generatorCheckbox.getState());
		if (kte.getOrientation() == -1) arrowSelect.select(0);
		else arrowSelect.select(kte.getOrientation());

		Rectangle r = ktt.getBounds();
		r.x = kinTerm.getBounds().x;
		r.y = kinTerm.getBounds().y;
		ktt.setBounds(r);
		textField1.selectAll();
		if (kinTerm.isFirstTime()) {
			etcCheckbox.setVisible(true);
			etcCheckbox.setState(false);
		} else if (kinTerm.isEtc()) {
			etcCheckbox.setVisible(true);
			etcCheckbox.setState(true);
		} else if (!kinTerm.isEtc()) {
			etcCheckbox.setVisible(true);
			etcCheckbox.setState(false);
		}
		ktt.setVisible(true);
		// Debug.prout(4,"YYY");
	}

	class SymMouse extends java.awt.event.MouseAdapter
	{
		public void mousePressed(java.awt.event.MouseEvent event)
		{
			//sendMouseEventToChildren(event);
			Object object = event.getSource();
			if (object == KinshipTermsPanel.this)
				KinshipTermsPanel_MousePressed(event);
		}
		public void mouseReleased(java.awt.event.MouseEvent event)
		{
			//sendMouseEventToChildren(event);
			Object object = event.getSource();
			if (object == button2)
				button2_MouseReleased(event);
			else if (object == KinshipTermsPanel.this)
				KinshipTermsPanel_MouseReleased(event);
		}
	}

	void button2_MouseReleased(java.awt.event.MouseEvent event)
	{
		// Make KinshipTermsPanel resizable
		if (kinTerm == null) return;
		kinTerm.setTheTerm(textField1.getText());
		//kinTerm.setSex(sexChoice.getSelectedItem().substring(0,1));
		if (!kinTerm.isCovered()) kinTerm.setGenerating(generatorCheckbox.getState());
		kinTerm.setEtc(etcCheckbox.getState());
		etcCheckbox.setVisible(false);
		if (generatorCheckbox.getState()) {
			kinTerm.setOrientation(arrowSelect.getSelectedIndex());
		}
		kinTerm.setSex(sexChoice.getSelectedItem().substring(0,1));
		//kinTerm.setSex(maleradioButton1.getCheckboxGroup().getSelectedCheckbox().getLabel().substring(0,1));
		touchypanel.setVisible(false);
		kinTerm.redrawOthers();
		kinTerm = null;
		repaint();
		updateKintable();
	}

	public void update(Graphics g) {
		// to suppress erase
		paint(g);
	}

	public void paintx(Graphics g) {
		g.setClip(0,0,getBounds().width,getBounds().height);
		g.clearRect(0,0,getSize().width, getSize().height);
		super.paint(g);
		//		super.paint(graphicsBuff);

		// g.drawImage(imageBuff, 0, 0, null);
		//paint0(g);
	}

	public boolean isDoubleBuffered() {
		return true;
	}

	public void paintXX(Graphics g) {
		g.setClip(0,0,getBounds().width,getBounds().height);
		if (imageBuff == null) {
			imageBuff = createImage(getSize().width, getSize().height);
			graphicsBuff = imageBuff.getGraphics();
		}
		// graphicsBuff = g;
		graphicsBuff.clearRect(0,0,getSize().width, getSize().height);
		//paint1(g); //
		super.paint(graphicsBuff);
//		super.paint(g);
		g.drawImage(imageBuff, 0, 0, null);
		//paint0(g);
		if (MainFrame.kmap != null) {//small kin term map window
			MainFrame.kmap.setImage(imageBuff,getActiveBox());
			MainFrame.kmap.repaint();
		}
	}

	public void paint(Graphics g) {
		g.setClip(0,0,getBounds().width,getBounds().height);
		if (imageBuff == null) {
			imageBuff = createImage(getSize().width, getSize().height);
			graphicsBuff = imageBuff.getGraphics();
		}
		// graphicsBuff = g;
		graphicsBuff.clearRect(0,0,getSize().width, getSize().height);
		super.paint(graphicsBuff);
		//super.paint(g);
		g.drawImage(imageBuff, 0, 0, null);
		//paint0(g);
		if (MainFrame.kmap != null) {
			MainFrame.kmap.setImage(imageBuff,getActiveBox());
			MainFrame.kmap.repaint();
		}
	}



	public Image getImage() {
		return imageBuff;
	}

	Graphics realGraphics =null;
	static private Image imageBuff = null;
	static private Graphics graphicsBuff;

	boolean tick=true;

	public Graphics getGraphicsx() {
		if (imageBuff == null) {
			imageBuff = createImage(getSize().width, getSize().height);
		}
		return imageBuff.getGraphics();
	}

    public void paint1(Graphics g) {
		if (isShowing()) {
			int ncomponents = this.getComponentCount();
			Rectangle clip = g.getClipRect();
			for (int i = ncomponents - 1 ; i >= 0 ; i--) {
				Component comp = getComponent(i);
				if (comp != null &&
		//comp.getPeer() instanceof java.awt.peer.LightweightPeer &&
		comp.isVisible() == true) {

					Rectangle cr = comp.getBounds();
					if ((clip == null) || cr.intersects(clip)) {
						Graphics cg = graphicsBuff; // g.create(cr.x, cr.y, cr.width, cr.height);
						try {
							comp.paint(cg);
						} finally {
							// cg.dispose();
						}
					}
				}
			}
		}
    }

    public void paintComponentsx(Graphics g) {
    	int ncomponents = this.getComponentCount();
		for (int i = ncomponents - 1 ; i >= 0 ; i--) {
		    Component comp = getComponent(i);
		    if (comp != null) {
	                Graphics cg = graphicsBuff; // comp.getGraphics();
	                Rectangle parentRect = g.getClipRect();

	                // Calculate the clipping region of the child's graphics
	                // context, by taking the intersection of the parent's
	                // clipRect (if any) and the child's bounds, and then
	                // translating it's coordinates to be relative to the child.
	                if (parentRect != null) {
	                    Rectangle childRect = comp.getBounds();
	                    if (childRect.intersects(parentRect) == false) {
	                        // Child component is completely clipped out: ignore.
	                        continue;
	                    }
	                    Rectangle childClipRect =
	                        childRect.intersection(parentRect);
	                    childClipRect.translate(-childRect.x, -childRect.y);
	                    cg.clipRect(childClipRect.x, childClipRect.y,
	                                childClipRect.width, childClipRect.height);
	                }

					try {
					    comp.paintAll(cg);
					} finally {
					  //  cg.dispose();
					}
		    }
		}
    }

	public void paint0( Graphics g ) {
		// allocate an offscreen buffer if first time through
		// paintBackground(graphicsBuff);
		// paint each tile, starting in upper-right conrner, progressing
		//  to lower-left, from lowest layer to highest
		/*for (int z=0; z<BOARDZ; z++)
   			for (int y=0; y<BOARDY; y++)
   				for (int x=(BOARDX-1); x>=0; x--)
   					layout[x][y][z].paint(graphicsBuff);
   					*/
		// now blit the buffer to screen
		g.drawImage(imageBuff, 0, 0, null);
	}
	// =========================================================
	/*public void paintBackground( Graphics g ) {
		g.drawImage(background, 0, 0, null);
	}
*/

	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();

		}
	}

	Vector kinterms = new Vector(15);



	void KinshipTermsPanel_MousePressed(java.awt.event.MouseEvent event)
	{
		// to do: code goes here.

		//{{CONNECTION

		//}}
	}

	void KinshipTermsPanel_MouseReleased(java.awt.event.MouseEvent event)
	{
		// to do: code goes here.
		LineObject l = clickedLine(event.getX(),event.getY());
		if (l != null) {
			Debug.prout(4,"............ Line clicked ..............");
			mants.setSelectedLine(l);
		} else clearSelected();
	}

	class SymMouseMotion extends java.awt.event.MouseMotionAdapter
	{
		public void mouseMoved(java.awt.event.MouseEvent event)
		{
			Object object = event.getSource();
			if (object == KinshipTermsPanel.this)
				KinshipTermsPanel_MouseMoved(event);
		}

		public void mouseDragged(java.awt.event.MouseEvent event)
		{
			//sendMouseEventToChildren(event);
			Object object = event.getSource();
			if (object == KinshipTermsPanel.this)
				KinshipTermsPanel_MouseDragged(event);
		}
	}

	void KinshipTermsPanel_MouseDragged(java.awt.event.MouseEvent event)
	{
		// to do: code goes here.
		//clearSelected();
		//{{CONNECTION

		//}}
	}

	public void drawTermLine(LineObject l) {
		Graphics g = getGraphics();
		g.setColor(l.colour);
		g.drawLine(l.startPoint.x, l.startPoint.y, l.endPoint.x, l.endPoint.y);
//		g.fillRect(l.endPoint.x - 5,l.endPoint.y-5,10,10);
//		Debug.prout(4,"Iine="+l.startPoint.toString()+" "+l.endPoint.toString());
	}

	void sendMouseEventToChildren(MouseEvent e) {
		Component o = (Component) e.getSource();
		Point t = e.getPoint();
		Point l = o.getLocation();
		Point axy;
		if (o != this) axy = new Point(l.x+t.x,l.y+t.y);
		else axy = t;

		Component[] c = getComponents();
		for(int i=0;i<c.length;i++) {
			if (c[i] == o) continue;
			// Debug.prout(4,c[i].getName() + " loc=" + c[i].getLocation().toString() +
			// " axy=" + axy.toString());
			if (c[i].getBounds().contains(axy)) {
				Point n = c[i].getLocation();
				dispatchEvent(makeMouseEvent(e,c[i],axy.x, axy.y));
				//c[i].dispatchEvent( makeMouseEvent(e,c[i],axy.x - n.x, axy.y - n.y));
			}
		}
	}

	MouseEvent makeMouseEvent(MouseEvent e, Component o, int x, int y) {
		return new MouseEvent(o,
                                                                e.getID(),
								e.getWhen(),
								e.getModifiers(),
								x,
								y,
								e.getClickCount(),
								e.isPopupTrigger()
								);
	}

	class SymItem implements java.awt.event.ItemListener
	{
		public void itemStateChanged(java.awt.event.ItemEvent event)
		{
			Object object = event.getSource();
			if (object == generatorCheckbox) {
				generatorCheckbox_ItemStateChanged(event);
				
			}
				
			else if (object == etcCheckbox)
				etcCheckbox_ItemStateChanged(event);
		}
	}

	void generatorCheckbox_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		if (generatorCheckbox.getState()) {
			if (kinTerm.isCovered()) {
				generatorCheckbox.setState(false);
				return;
			}
		}
		arrowSelect.setVisible(generatorCheckbox.getState());
		touchypanel.repaint();
		repaint();
	}

	/* the following two routines and variable maintain a productlist that is intended to be shared
	   with its children... not actually implemented. See note in KintermEntry relating to lastProduct
	   */
	
	public ListVector getProductList() {
		return productList;
	}

	public void setProductList(ListVector p) {
		productList = p;
	}

	public ListVector productList=null;

	/** packs the terms in this panel into  a kinterm map structure
	*/

	public Rectangle getActiveBox() {
		int x1=10000,x2=-10000,y1=10000,y2=-10000;
		int x0,y0;

		Component c[] = getComponents();
		for (int i=0;i<c.length;i++) {
			if (c[i] instanceof KintermEditObject) {
				if ((x0 = c[i].getLocation().x) < x1) x1 = x0;
				if ((y0 = c[i].getLocation().y) < y1) y1 = y0;
				if ((x0 = (x0+c[i].getSize().width)) > x2) x2 = x0;
				if ((y0 = (y0+c[i].getSize().height)) > y2) y2 = y0;
			}
		}
		return new Rectangle(x1,y1,x2,y2);
	}

	public TransferKinInfoVector getTransferKinInfo() {
		TransferKinInfoVector v = new TransferKinInfoVector();
		Component c[] = getComponents();
		for (int i=0;i<c.length;i++) {
			if (c[i] instanceof KintermEditObject) { // patch up if changed!!!!!!!!!!!!!!!!!!!!!
				KintermEditObject ke = (KintermEditObject) c[i];
				v.addElement(ke.toKinTermInfo());
			}
		}
		v.setTheMaster(getTheMaster());
		v.buildTable();
		v.buildInverseTable();
		return v;
	}

        Hashtable kinHash=null;
	/** translates a kinterm map structure into a set of visual KinshipTerms
	@param kinfo the data structure that represents a kin term map
	*/

	public void buildKintermEntries(TransferKinInfoVector kinfo) {
		Debug.prout(4,"In buildKintermEntries");
		boolean inited = false;
		TransferKinInfo k;
		this.setVisible(false);
		Hashtable t = kinHash = new Hashtable(kinfo.size()*2);
		setTheMaster(kinfo.getTheMaster());
		for (getTheMaster().varnames.reset();getTheMaster().varnames.isNext();) {
			KintermEntry.kin.theVariables.masterRecord.defineVariable(getTheMaster().varnames.getNext());
		}
		for (int i=0;i<kinfo.size();i++) {
			k = kinfo.getSymbol(i);
			KintermEntry kt = new KintermEntryForm(k.getTheVariables());
			kinterms.addElement(kt);
			kt.setBounds(10,10,100,20);
			kt.setSex(k.getSex());
			kt.orientation = k.orientation;
			kt.setTheTerm(k.term);
			kt.generating = k.isGenerator();
			kt.setLocation(k.origin);
			kt.setIsCovered(k.isCovered);
			kt.setCoveringTerm(k.coveringTerm);
			kt.setCoveredTerms(k.coveredTerms);
			kt.setEtc(k.isEtc());
		 //	kt.setDropMerge(k.isDropMerge());
			kt.isFirstTime(); // clear first-time flag when loading
			add(kt);
			t.put(k.term,kt);
			// Debug.prout(4,""+k.term);
		}
//		Debug.prout(4,"here 1");
		for (kinfo.reset();kinfo.isNext();) {
			k = kinfo.getNext();
			KintermEntry xk = (KintermEntry) t.get(k.term);
//			if (xk == null) Debug.prout(4,"Term not found: "+k.term);
			if (xk.coveringTerm != null) {
				String x = (String) xk.coveringTerm;
				KintermEntry xx = (KintermEntry) t.get(x);
				xk.coveringTerm = xx;
			}
		}

//		Debug.prout(4,"here 2");

		for (int i=0;i<kinfo.size();i++) {
			k =  kinfo.getSymbol(i);
			KintermEntry kt = (KintermEntry) t.get(k.term);
			//KintermEntry kt = new KintermEntry();
			ProductVector pk = new ProductVector(); // kt.products; // new ProductVector();
			kt.products = pk;
			TransferProductsVector m = k.products;
			if (m != null) {
				Product p;
				for (int r=0;r<m.size();r++) {
					KintermEntryVector ko = new KintermEntryVector();
					Vector v = (Vector) m.elementAt(r);
					String gen = (String) v.elementAt(0);
					if (gen.equals("Kin")) {
						KintermEntry genTerm = kt.kin;
						p = new Product(genTerm,r);
					} else {
						KintermEntry genTerm = (KintermEntry) t.get(gen);
						if (genTerm == null) {
							Debug.prout(10,"Ouch "+v.toString());
							continue;
							// p = null; // new Product();
						} else p = new Product(genTerm,genTerm.getOrientation());
					}
					for (int j=1;j<v.size();j++) {
						String s = (String) v.elementAt(j);
						ko.addElement(t.get(s));
					}
					p.setTheLinks(ko);
					pk.addElement(p);
					//if (!inited) {
						kt.lastProducts = (ProductVector) kt.products.clone(true);
						inited = true;
					//}
				}
			}
		}
		// this.setBounds(0,185,973,450);
		this.setVisible(true);//makes kin term map visible
			updateKintable();
	}


	/** Save As... Clears xout and call saveKinData to save under new name
	*/

	XFile txout = null;

	public void saveKinDataInNewFile() {
		txout = xout;
		xout = null;
		saveKinData();
	}

	public void saveKinDataInNewFile(KintermFrame f) {
		txout = xout;
		xout = null;
		saveKinData(f);
	}

	/** Saves kinship data in file using XML format using a kinterm map
		associated with this KinshipTermsPanel
	*/

	public void saveKinData() {
		saveKinData(getTransferKinInfo());
	}

	public void saveKinData(KintermFrame f) {
		TransferKinInfoVector k = getTransferKinInfo();
		k.kinPreferences = f.docPreferences;
		saveKinData(k);
	}

	XFile xout = null;

	/** Saves kinship data in file using XML format

	@param v the data structure that represents a kin term map

	*/

	public void saveKinData(TransferKinInfoVector v) {
		if (xout == null) {
			 xout = new XFile();
			if (!xout.Choose(XFile.WRITE,"kinmap.xml","Save to file...")) {
				xout = txout; // leave original xfile in place for next time
			 	return;
			}
		 }
		if (xout.OpenPrint()) {
			xout.WriteString(v.toXML());
			xout.Close();
		} else {
			Debug.prout(0,"Couldn't open file for saving!");
			xout = txout; // so won't try to reuse!
		}
	}


	/** Loads in kinship data from file in XML format
	*/

	public void loadKinData() {
		loadKinData(new KintermFrame());
	}

	public void loadKinData(KintermFrame x) {
		xout = new XFile();
		if (xout.Choose(XFile.READ,"kinmap.xml","Open file...")) {
			loadKinData(xout,x);
		}
	}

	public void loadKinData(String filename, KintermFrame x) {
		//KintermFrame x = new KintermFrame();
		xout = new XFile(filename);
		loadKinData(xout,x);
	}

	public void loadKinData(XFile xout, KintermFrame x) {
		if (xout.Open()) {
			KintermMapHandler kt = new KintermMapHandler();
			try {
				kt.doParse(xout);
				TransferKinInfoVector k = kt.kinTermVector;
				// KintermFrame x = new KintermFrame();
				Point p = getParent().getLocation();
				p.translate(10,10);
				x.setLocation(p);
				x.kinshipTermsPanel1.buildKintermEntries(k);
				x.docPreferences = k.kinPreferences;
				x.kinshipTermsPanel1.xout = xout; // for save to know current file
				x.setFromPreferences();
				x.show();
			} catch (Exception e) {
				Debug.prout(0,e.toString());
				xout = null; // so won't try to reuse!
			}
		}
	}

void etcCheckbox_ItemStateChanged(java.awt.event.ItemEvent event)
	{
			if (etcCheckbox.getState()) {
				String x = textField1.getText();
				if (x.equalsIgnoreCase("Etc") || x.equals("") || x.equals("Click to enter kin term")) {
					Component[] c = getComponents();
					String t;
					int ndx;
					String alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
					for(int i=0;i<c.length;i++) {
						if (!(c[i] instanceof KintermEditObject)) continue;
						t = ((KintermEditObject)c[i]).getTheTerm();
						if (t.length() != 5) continue;
						if (t.substring(0,3).equalsIgnoreCase("Etc")) {
							t = t.substring(4,5);
		//Debug.prout(4,"x="+t);
						//if (t.length() > 1) continue;
							t = t.toUpperCase();
							if ((ndx = alphabet.indexOf(t)) != -1) 
								alphabet = alphabet.substring(0,ndx)+alphabet.substring(ndx+1);
						}
					}
					t = "etc-"+alphabet.substring(0,1);
					kinTerm.setTheTerm(t);
					textField1.setText(t);
				} else if (x.length() < 4 || (!x.substring(0,2).equalsIgnoreCase("Etc") && !x.endsWith("-etc"))) {
					kinTerm.setTheTerm(x+"-etc");
					textField1.setText(x+"-etc");
				}
			}
	}

	void newTerm()
	{
		//{{CONNECTION
		KintermEntry kt = new KintermEntryForm();
		kt.setTheVariables(theMaster.newVariableSet());
		kinterms.addElement(kt);
		kt.setBounds(ktBoundsProto);
		ktBoundsProto.x += 150;
		if (ktBoundsProto.x > 680) {
			ktBoundsProto.x = 10;ktBoundsProto.y += 60;
		}
		add(kt);
		validate();
		repaint();
		updateKintable();
		//}}
	}

public Rectangle ktBoundsProto = new Rectangle(10,10,100,20);
void coverTerms(KintermEntry k1, KintermEntry k2)
{
    KintermEntry m1[] = new KintermEntry[2];
    int kindex=0;
    if (k1.getOrientation() != k2.getOrientation()) return; // must match .. feedback
    // other checks for strucdtureal equivalence

    TransferKinInfoVector kw = getTransferKinInfo(); // get the current set of term states
	TransferKinInfo tk1, tk2;
	tk1 = kw.lookupTerm(k1.getTheTerm());
	tk2 = kw.lookupTerm(k2.getTheTerm());
	if (tk1.equals(tk2)) return;
	// test to see if the pattern of 'out' arrows match
	if (!tk1.outArrowsIdentical(tk2)) return; // do not merge
	 // test to see if the pattern of 'in' arrows match
	if (!kw.inArrowsSimilar(tk1, tk2)) return; // do not merge
	
	clearSelected();
    Component c[] = getComponents();
    int len = c.length;
    for (int i=len-1;i>=0;i--) {
        if (c[i] instanceof KintermEditObject) { // patch up if changed!!!!!!!!!!!!!!!!!!!!!
            if (c[i] == k1 || c[i] == k2) m1[kindex++] = (KintermEntry) c[i];
           remove(c[i]);
        }
    }
   StringVector lv= new StringVector();
    lv.add(m1[0].getTheTerm());
    lv.add(m1[1].getTheTerm());
    kw.mergeTerms(lv,true); // use the dropMerge variant 13-1-2003 mf
	
    kw.buildTable();
    kw.buildInverseTable();

	// kw.mergeArrows();
	// if (tk1.orientation != -1) kw.mergeGenerators(lv);

    lv = kw.findFocalTerms(); // --- need to calc focal terms

    buildKintermEntries(kw);
    k1 = (KintermEntry) kinHash.get(m1[0].getTheTerm());
    k2 = (KintermEntry) kinHash.get(m1[1].getTheTerm());
    KintermEntry k3 = (KintermEntry) kinHash.get("["+m1[0].getTheTerm()+", "+m1[1].getTheTerm()+"]");
    repaint();
}

/*void yxcoverTerms(KintermEntry k1, KintermEntry k2)
{
    //{{CONNECTION
    KintermEntry kt = new KintermEntry();
    kt.setTheVariables((Variables) k1.getTheVariables().clone());
    clearSelected();
  //  k1.setVisible(false);
  //  k2.setVisible(false);
    kt.setBounds(k1.getBounds());
    kt.setTheTerm(k1.getTheTerm()+"+"+k2.getTheTerm());
    if (k1.getSex().equals(k2.getSex())) kt.setSex(k1.getSex());
    else kt.setSex("N");
    kt.setGenerating(false);
    k1.isCovered.setTrue();
    k2.isCovered.setTrue();
    //  k2.setIsCovered(new BooleanSwitch(true));
    kt.setIsCovered(k1.isCovered);
    k1.coveringTerm = kt;
    k2.coveringTerm = kt;
    StringVector sv = new StringVector(2);
    sv.add(k1.getTheTerm());
    sv.add(k2.getTheTerm());
    kinterms.addElement(kt);
    kt.setCoveredTerms(sv);
  //  ListVector a1 = k1.getProductList();
  //  ListVector a2 = k2.getProductList();
   // a2.appendUnique(a1);
   // kt.setProductList(a2);
    add(kt);
    if (k1.getOrientation() == k2.getOrientation()) {
        kt.setOrientation(k1.getOrientation());
        kt.setGenerating(k1.generating);
    }
  //  newStructure(); 
  //  validate();
  //  repaint();
    //}}
}
*/
	void newMap()
	{
		TransferKinInfoVector k = getTransferKinInfo();
		KintermFrame x = new KintermFrame();
		Point p = getLocation();
		p.translate(10,10);
		x.setLocation(p);
		x.kinshipTermsPanel1.buildKintermEntries(k);
		x.show();
	}

	String findFocalElements()
	{
		//{{CONNECTION
		// Append string in TextArea

		TransferKinInfoVector vx = getTransferKinInfo();
		StringVector v = vx.findFocalTerms();
		return (v.toString());
		//}}
	}

	public TransferKinInfoVector mergeStructure()
	{
		//{{CONNECTION
			TransferKinInfoVector k = getTransferKinInfo();
			TransferKinInfoVector kw = k.deepClone();
			ListVector lv= new ListVector();
			lv = kw.findStructuralEquivalents();
			kw.mergeTerms(lv);
			kw.buildTable();
			kw.buildInverseTable();
		    StringVector fk = kw.findFocalTerms(); // --- need to calc focal terms
			return kw;
		//}}

	}

	void newStructure()
	{
			TransferKinInfoVector kw = mergeStructure();
			KintermFrame x = new KintermFrame();
			Point p = getParent().getLocation();
			p.translate(10,10);
			x.setLocation(p);
			x.kinshipTermsPanel1.buildKintermEntries(kw);
			x.show();
	}



	public void setTheMaster(VariablesFactory theMaster) {
		this.theMaster = theMaster;
	}

	public VariablesFactory getTheMaster() {
		return theMaster;
	}

	protected VariablesFactory theMaster= new VariablesFactory();

	class SymComponent extends java.awt.event.ComponentAdapter
	{
		public void componentResized(java.awt.event.ComponentEvent event)
		{
			Object object = event.getSource();
			if (object == KinshipTermsPanel.this)
				KinshipTermsPanel_componentResized(event);
		}
	}

	void KinshipTermsPanel_componentResized(java.awt.event.ComponentEvent event)
	{
		// to do: code goes here.
	}

	public LineObject clickedLine(int x, int y) {
		//Component c[] = getComponents();
		LineObject l = null;
		//Debug.prout(4,"Component Count="+c.length);
	/*	for (int i=0;i<c.length;i++) {
			if (c[i] instanceof KintermEntry) {
	*/
		if (selected != null) {
			l = (selected).searchLines(x,y);
		}
		/*	//Debug.prout(4,"Doing component "+i);
		}*/
		mants.dorment();
		mants.setSelectedLine(l);
		mants.active();
		return l;
	}

	KintermEditObject selected=null;

/** selects a term from this editor
	*	@param k The term to select
**/
	public void select(KintermEditObject k) {
		if (selected != null) clearSelected();
		else mants.dorment();
		selected = k;
		mants.initBorder(k.getBounds(),this);
		mants.active();
		if (touchypanel.isVisible()) touchypanel.setVisible(false);
		Debug.prout(4, "Generating "+k.isGenerating()+" orientation "+k.getOrientation());
	}

/** returns the current selected term for this editor
	* @return the selected term
**/
	public KintermEditObject getSelected() {
		return selected;
	}

/** clear the current selected term for this editor
**/
	public void clearSelected() {
		mants.dorment();
		mants.clearSelectedLine();
		selected = null;
		if (touchypanel.isVisible()) touchypanel.setVisible(false);
		repaint();
	}

/** clear the current selected term for this editor
**/
	public void updateSelected() {
		if (selected == null) return;
		mants.dorment();
		mants.updateBorder(selected.getBounds());
		mants.clearSelectedLine();
		mants.active();
		repaint();
	}

/** removes a term from this editor
	*	@param k The term to remove
**/
	public void removeTerm(KintermEditObject k) {
		k.delete();
		remove((Component) k);
	}

/** removes the selected term from this editor
**/
	public void removeTerm() {

		if (selected != null) {
			KintermEditObject xSelect = selected;
			clearSelected(); // repaint done in clearSelected
			xSelect.delete();
			remove((Component) xSelect);
		}
	}

	void KinshipTermsPanel_MouseMoved(java.awt.event.MouseEvent event)
	{
		LineObject lo;
		requestFocus();
		if (selected != null) {
			lo = selected.searchLines(event.getX(),event.getY());
			if (lo != null) {
				setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
			} else {
				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			}
		} else setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
	}

	public void deleteLine() {
		if (selected == null) return;
		if (mants.getSelectedLine() == null) return;
		mants.dorment();
		selected.removeTerm(mants.getSelectedLine().getKinterm(), mants.getSelectedLine().getProduct());
		mants.clearSelectedLine();
		mants.active();
		repaint();
	}


	class SymKey extends java.awt.event.KeyAdapter
	{
		public void keyReleased(java.awt.event.KeyEvent event)
		{
			Object object = event.getSource();
			if (object == KinshipTermsPanel.this)
				KinshipTermsPanel_KeyReleased(event);
		}
	}



	void KinshipTermsPanel_KeyReleased(java.awt.event.KeyEvent event)
	{
		int c=event.getKeyCode();
		Debug.prout(4,"Key Released Keycode "+c);
		if (c == event.VK_DELETE || c == event.VK_BACK_SPACE) {
			deleteLine();
		}
		// to do: code goes here.
	}

public void doKintable() {
	if (cFrame == null) cFrame = ((KintermFrame) getParent().getParent()).cFrame;
	if (cFrame == null) {
		cFrame = new KintermTextEntryForm();
		//cFrame.setSize(830,620);
		// cFrame.setTitle("Kinterm Table");
		((KintermFrame)getParent()).cFrame = cFrame;
		GlobalWindowManager.addWindow(cFrame);
	}
	updateKintable();
}

public void updateKintable() {
	//cFrame.setVisible(false);
	if (cFrame == null) return;
	cayleyPanel = makeKintablePanel();
	cFrame.removeAll();
	cFrame.add(cayleyPanel);
	cayleyPanel.repaint();
}

StringVector termList = new StringVector();
ListVector ktList = new ListVector();


	public Panel makeKintablePanel() {
		// System.out.println("Making CayleyPanel");
		termList = new StringVector();
		ktList = new ListVector();
		KinshipTermsMapPanel p = new KinshipTermsMapPanel(this);
		//p.setLayout(null);
		//p.setSize(800,800);
	//	Panel x = (Panel) ((Panel) touchypanel).clone();
	//	p.add(x);
		int loc = 40;
		boolean swi=false;
		Panel xx;
		termChoices = new Choice();p.add(termChoices);termChoices.setVisible(false);
		Component c[] = getComponents();
		boolean gendone=false;
		for (int i=0;i<c.length;i++) {
			if (c[i] instanceof KintermEntryForm) { // patch up if changed!!!!!!!!!!!!!!!!!!!!!
				if (!gendone) {
					p.add(xx = ((KintermEntryForm)c[i]).kinText.getGeneratorPanel());
					gendone = true;
					xx.setLocation(15,loc); loc+=20;
					Label q = new Label("Terms");
					q.setSize(30,20);
					//q.setForeground(Color.black);
					//q.setBackground(Color.yellow);
					p.add(q);
					//q.setVisible(true);
					q.setLocation(15,loc);loc += 25;
				}
				// ((KintermEntryForm)c[i]).kinText.updateInfo();
				p.add(xx = ((KintermEntryForm)c[i]).kinText.updateInfo());
				termList.addElement(((KintermEntryForm)c[i]).getTheTerm());
				ktList.addElement(((KintermEntryForm)c[i]));
				//if (swi) xx.setBackground(Color.red);
				//else xx.setBackground(Color.green);
				swi = !swi;
				xx.setLocation(15,loc);loc += 16;
			}
		}
		
		p.newKintableTermButton = new Button("New Term");
		p.newKintableTermButton.addActionListener(p.lSymAction);
		p.newKintableTermButton.setSize(90,25);
		p.add(p.newKintableTermButton);
		p.newKintableTermButton.setLocation(15,loc+20);
		QSort qs = new QSort();
		int [] ndx=null;
		try {
			ndx = qs.sort(termList);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		
		for (int i=0;i<ndx.length;i++) {
			termChoices.addItem(termList.getSymbol(ndx[i]));
		}
		termChoices.addItem("");
		System.out.println("Terms = " + termList.toString());
		return p;
	}

	Choice termChoices = new Choice();
}

