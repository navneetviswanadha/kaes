import java.awt.Graphics;
import java.awt.*;
import java.awt.Component;
import java.awt.Container;
import java.util.*;

/*
 MF NOTE: Currently lastProducts is a static variable ... this prevents working on two terminologies at one time. Will need to maintain a different way ... problem is that we need at creation time, but component does not have a parent at that time ...
 */

/*History
* 10/12 DR  added getSexColour to use with coloring algebra graphs
* 10/3  MF  added call to get graphics buffer from parent to fetch
            offscreen buffer to reduce flashing. Works pretty well.
            Should change name f routine to something a bit more
            descriptive. Current getGraphicsx(); Also need to move
            whatever I call the method to the interface for the parent
            to reduce specific dependency on KinshipTermsPanel.
* 1/8 MF corrected some small defects for line drawing
* 15/10 MF Improved line selection
* 15/11 MF Changed buffering. Need to adjust for Mac OSX (impacts 'marching ants and line selection feedback due to inbuilt double buffering.
* 10/28 DR added setArrowColor, setTermColor, setTabColor and new colors to color code arrows\
* with generators; new colors are variants on the generator colors
*/

/** Individual element/entity in the kin term map
*/

public class KintermEntry extends java.awt.Container implements KintermEditObject
{
    //insert class definition here
//I added the following flag to turn part of the drawing procedure off to simplify the kin term map
    boolean drawFlag = true;

   public void registerListeners() {
        //{{REGISTER_LISTENERS
        SymMouse aSymMouse = new SymMouse();
        this.addMouseListener(aSymMouse);
        SymMouseMotion aSymMouseMotion = new SymMouseMotion();
        this.addMouseMotionListener(aSymMouseMotion);
        //}}
      
   }
    
    public KintermEntry()
    {
        // This code is automatically generated by Visual Cafe when you add
        // components to the visual environment. It instantiates and initializes
        // the components. To modify the code, only use code syntax that matches
        // what Visual Cafe can generate, or Visual Cafe may be unable to back
        // parse your Java file into its visual environment.
        //{{INIT_CONTROLS
        setSize(278,56);
        //}}
       
       registerListeners();
       
        setLayout(null); // layout ourselves.
        // Must convert over to KintermEntryFactory !!!!!!!!!!!!!!!!!!
        if (kin != null) { // initialize the default relationship for each orientation .... kin has sex == none, draws in black.
            ProductVector p;
            if ((p = getLastProducts()) != null) {
                products = (ProductVector) p.clone(true);
            } else {
                /* misaligning orientations with product list 
                addProduct(kin,null,UP); // above test is to avoid conflict when initializing the static type kin.
                addProduct(kin,null,DOWN);
                addProduct(kin,null,RIGHT);
                addProduct(kin,null,LEFT);
                addProduct(kin,null,SPOUSE);
                addProduct(kin,null,SPOUSER);
                 */
                for(int i=0;i<ORIENTATIONS.length;i++) {
                    addProduct(kin,null,ORIENTATIONS[i]);
                }
                setLastProducts((ProductVector) products.clone(true));
            }
        } else { // it is Kin!!!!!!! so set up its variables etc.
            setTheVariables(new Variables());
            getTheVariables().masterRecord = new VariablesFactory();
        }

        for(int i = 0;i< newHooks.length;i++) newHooks[i] = new Rectangle(0,0,HHEIGHT,HWIDTH);
    }

    public KintermEntry (Variables v) {
        this();
        setTheVariables(v);

        v.setVarValue("Sex","M");
        v.addVarValue("Sex","F");
    }

    /** last products Vector initialised... so that we can construct a common list

      Will need to change this later to a more reentrant form ... use get and set routines so transition will be painless!
    */
     public static ProductVector lastProducts=null;

   public ProductVector getLastProducts() {
      return lastProducts;
   }
   
   public void setLastProducts(ProductVector pv) {
      lastProducts=pv;
   }
   
    /** @param term The kinship term
    * @param isGenerator This is a generating element.
    * should be sure to do setOrientation() to make this an active generator for all terms.
    * @see #setOrientation;
    */
    public KintermEntry(String term, boolean isGenerator) {
        this();
        setTheTerm(term);
        setGenerating (isGenerator);
    }

    //{{DECLARE_CONTROLS
    //}}

    /**
    * We override this method so that nothing gets added to this component
    * @param comp the component to be added
    * @param constraints an object expressing layout contraints for this
    * component
    * @param index the position in the container's list at which to
    * insert the component.  -1 means insert at the end.
    * @see #remove
    * @see LayoutManager
    */
    protected void addImpl(Component comp, Object constraints, int index) {
        //do nothing
    }

    public void setDrawFlag(boolean flag) {
        drawFlag = flag;
    }

    /** set the kinship term.
    * @param theTerm the kinship term
    */
    public void setTheTerm(String theTerm) {
        this.theTerm = theTerm;
    }

    /** get the kinship term.
    * @returns the kinship term
    */
    public String getTheTerm() {
        return theTerm;
    }

    /** Set the sex or gender of the kinship term
    * internally stored as M for male, F for female and N for neutral
    * @param sex the gender of the kinship term
    */
    public void setSex(String sex) {
        this.sex = sex;

        if (sex.equals("M")) {
//System.out.println(" orient "+this.orientation);
        if (orientation == ArrowPanel.LEFT){
            theColour = Color.green;
            subSex = 0;
        }
        else if (orientation == ArrowPanel.RIGHT){
            theColour = Color.orange;
            subSex = 0;
        }
        else{
            theColour = Color.blue;
            subSex = 0;
        }
            theVariables.setVarValue("Sex","M");
        }
        else if (sex.equals("F")) {
            theColour = Color.red;
            subSex = 2;
            theVariables.setVarValue("Sex","F");
        }
        else {
            theColour = Color.gray;
            theVariables.setVarValue("Sex","M");
            theVariables.addVarValue("Sex","F");
            subSex = 1;//neutral
        }
    }

    /** Get the sex or gender of the kinship term
    * internally stored as M for male, F for female and N for neutral
    * @returns the gender of the kinship term
    */
    public String getSex() {
    //  System.out.println("The Variables="+theVariables);
        return theVariables.getVarValue("Sex");
        //return sex;
    }

    /** Set or clear this as a generating kinship term. The generating terms or elements are kinship terms
    * that form products with the current term, resulting in a kinship term (or terms).
    * For example in AKT using Parent as a generating term, self x Parent = Parent. Parent x Parent = Grandparent.
    * In the present formulation a generating term must have a Sex and an orientation (UP, Down Right or Left,
    * for ancestral, descendent, collateral+ and collateral-. The meanings of these are specific to specific
    * terminologies.
    * All generators exist for all members of KintermEntry in the same Container. That is, when a generator is defined
    * it is entered into a table for each KintermEntry component in the parent Container, though the specific products
    * will be unique to each term.
    * Initially there is one default generating term, called kin, that has a sex of N and an orientation of NONE (-1). No
    * other generators can have an orientation of NONE, and the KintermMap is not complete until there are no lines
    * with an orientation of NONE.
    * @param generating the generating status of the kinship term
    */
    public void setGenerating(boolean generating) {

        if (!generating && this.generating) {
            deleteThisAsGenerator();
        } // else will be handled in orientation
        this.generating = generating;
    }

    /** Set the orientation for a generator. Makes a generator if the term is not
    *   already a generator. This procedure prevents a singe term having two orientations.
    *   Check out the other structures to see if it is possible to allow this, though
    *   multiple orientations would require some means of having them set other than
    *   the ones currently provided by the user interface.
    *   @param orientation - the orientation to set or reset
    **/

    public void setOrientation(int orientation) {
        int index;
        if ((index = isProduct(this, this.getOrientation())) != -1) { // in the list of products as generator
            if (orientation != this.orientation) {
                deleteThisAsGenerator();
                this.orientation = orientation;
                if ((index = isProduct(this, orientation)) == -1) {
                    addThisAsGenerator(orientation);
                }
             }
        } else {
            this.orientation = orientation;
            if ((index = isProduct(this, orientation)) == -1) {
                addThisAsGenerator(orientation);
            }
        }
    }

    public void deleteGenerator(int index) {
        products.deleteGenerator(index);
    }

    /** Remove this as a generator if the term is already a generator.
    **/

    public void deleteThisAsGenerator() {
        if (this.generating) { // delete from all the product sets!!!!!!!!!!!!!!!!!!!!!
            int index;
            if ((index = isProduct(this, this.getOrientation())) != -1) { // in the list of products as generator
                getLastProducts().deleteGenerator(index);
                Component c[] = getParent().getComponents();
                for (int i=0;i<c.length;i++) {
                    if (c[i] instanceof KintermEditObject) { // patch up if changed!!!!!!!!!!!!!!!!!!!!!
                        //System.out.println(((KintermEntry)c[i]).toString());
                       ((KintermEditObject)c[i]).deleteGenerator(index);
                    }
                }
            }

        }
    }

    /** adds a Generator to the product set of this term
    * @param k the KintermEntry that has been made a generator
    * @param orient the orientation of the generator
    **/

    public void addGenerator(KintermEntry k, int orient) {
        products.addGenerator(k, orient);
    }

    /** adds this as Generator to its product set and all other terms
    * @param orientation the orientation of this generator
    **/
    public void addThisAsGenerator(int orientation) {
//      ProductVector prod = (ProductVector) ((KinTermEditor) getParent()).getProductList();
        ProductVector prod = getLastProducts(); // the master list
        if (prod.indexOf(new Product(this,orientation)) == -1) {
            prod.addGenerator(this,orientation);

            Component c[] = getParent().getComponents();
            for (int i=0;i<c.length;i++) {
                if (c[i] instanceof KintermEntry) { // patch up if changed!!!!!!!!!!!!!!!!!!!!!
                    ((KintermEntry)c[i]).addGenerator(this,orientation);
                }
            }
        }
    }

    /** redraw all terms
    **/

    public void redrawOthers() {
        getParent().invalidate();
        Component c[] = getParent().getComponents();
        for (int i=0;i<c.length;i++) {
            if (c[i] instanceof KintermEntry) { // patch up if changed!!!!!!!!!!!!!!!!!!!!!
                KintermEntry ke = (KintermEntry) c[i];
                ke.invalidate();
            }
        }
    }

    /** Is this a generating kinship term? The generating terms or elements are kinship terms
    * that form products with the current term, resulting in a kinship term (or terms).
    * For example in AKT using Parent as a generating term, self x Parent = Parent. Parent x Parent = Grandparent.
    * In the present formulation a generating term must have a Sex and an orientation (UP, Down Right or Left,
    * for ancestral, descendent, collateral+ and collateral-. The meanings of these are specific to specific
    * terminologies.
    * @return the generating status of the kinship term
    */

    public boolean isGenerating() {
        return generating;
    }
    int width = 140;
    int height = 20;

    /**
     * Returns the minimum size of this container.
     * @see #getPreferredSize
     */
    public Dimension getMinimumSize() {
        java.awt.Dimension supersResult = new Dimension(width,height);

        // to do: place event handler code here.
        // modify the return from the super, or return your own result

        return supersResult;
    }

    /**
     * Returns the preferred size of this container.
     * @see #getMinimumSize
     */
    public Dimension getPreferredSize() {
        java.awt.Dimension supersResult = new Dimension(width,height);

        // to do: place event handler code here.
        // modify the return from the super, or return your own result

        return supersResult;
    }
Color blueU = new Color(0,0,100,200);
Color blueD = new Color(0,0,255,80);
Color greenR = new Color(0,225,0,150);
Color greenL = new Color(0,178,0);
//Color greenR = new Color(0,225,0,150);
//Color greenL = new Color(0,178,0);
Color redU = new Color(200,0,0,175);
Color redD = new Color(255,0,0,80);
//Color orangeR = new Color(255,200,0,150);
//Color orangeL = new Color(220,178,0);
Color orangeR = new Color(255,200,0,150);
Color orangeL = new Color(220,178,0);


    Color setArrowColor(Color theColor,int arrowType) {
        if (arrowType == 0) return blueU;//arrow colors
        if (arrowType == 1) return blueD;
        if (arrowType == 2) return greenR;
        if (arrowType == 3) return greenL;
        
       // if (arrowType == 2) return greenL;
       // if (arrowType == 3) return greenR;
        if (arrowType == 12) return redU;
        if (arrowType == 13) return redD;
        //if (arrowType == 10) return orangeR;
       //if (arrowType == 11) return orangeL;
       if (arrowType == 14) return orangeR;
       if (arrowType == 15) return orangeL;
    return theColor;
    }

    Color setTabColor(Color theColor,int arrowType) {
        if (arrowType == 0) return blueD;//hook colors
        if (arrowType == 1) return blueU;
        if (arrowType == 2) return greenL;
        if (arrowType == 3) return greenR;
        
        //if (arrowType == 3) return greenL;
        //if (arrowType == 2) return greenR;
        if (arrowType == 12) return redD;
        if (arrowType == 13) return redU;
       // if (arrowType == 10) return orangeL;
       // if (arrowType == 11) return orangeR;
       if (arrowType == 14) return orangeL;
       if (arrowType == 15) return orangeR;
    return theColor;
    }

    Color setRectColor(Color theColor,int arrowType) {
        if (arrowType == 0) return blueU;//rect colors
        if (arrowType == 1) return blueD;
        if (arrowType == 2) return greenR;
        if (arrowType == 3) return greenL;
        
      //  if (arrowType == 2) return greenL;
     //   if (arrowType == 3) return greenR;
        if (arrowType == 12) return redU;
        if (arrowType == 13) return redD;
       // if (arrowType == 10) return orangeR;
       // if (arrowType == 11) return orangeL;
       if (arrowType == 14) return orangeR;
       if (arrowType == 15) return orangeL;
    return theColor;
    }

    Color setTermColor(Color theColor){
    if (orientation == 0) {
        if (subSex == 0) return blueU;
        if (subSex == 2) return redU;
    }
    else if (orientation == 1) {
        if (subSex == 0) return blueD;
        if (subSex == 2) return redD;
    }
    else if (orientation == 2) {
        if (subSex == 0) return greenR;//orientation == 2 is RIGHT is collateral-, subSex == 0 is male
       // if (subSex == 0) return greenL;
        //if (subSex == 2) return orangeL;
        if (subSex == 2) return orangeR;
    }
    else if (orientation == 3) {
        if (subSex == 0) return greenL;//orientation == 3 is LEFT is collateral+, subSex == 2 is female
      //  if (subSex == 0) return greenR;
        //if (subSex == 2) return orangeR;
         if (subSex == 2) return orangeL;
    }
    return theColor;
    }

    /**
     * Paints the container.  This forwards the paint to any lightweight components
     * that are children of this container.  If this method is reimplemented,
     * super.paint(g) should be called so that lightweight components are properly
     * rendered.  If a child component is entirely clipped by the current clipping
     * setting in g, paint() will not be forwarded to that child.
     *
     *This paint draws lines between the different members of KintermEntry in the same Container by calling
     * a routine in the parent Container, which must conform to Interface KintermEditor. These lines thus
     * exist in the parent coordinate space.
     * @param g the specified Graphics window
     * @see   java.awt.Component#update(java.awt.Graphics)
     */
    public void paint(Graphics g) {
       if (coveredTerms != null) {
          if (isCovered.isFalse()) {
             hide();
             return;
          } else show();
       } else if (coveringTerm != null) {
          if (isCovered.isTrue()) {
             hide();
             return;
          } else show();
       }
       super.paint(g);

       g.setFont(itsFont);
       setRectangles(g);
       FontMetrics fm = g.getFontMetrics();
       //super.paint(g);
       if (!isGenerating() && drawFlag)
          g.drawRect(textBox.x,textBox.y,textBox.width,textBox.height);
       //g.setColor(sexColours[subSex]);
       Color termColor = setTermColor(sexColours[subSex]);
       g.setColor(termColor);
       if (isGenerating()) {//generator
          g.setColor(new Color(termColor.getRed(),termColor.getGreen(),
                         termColor.getBlue(),20));
          g.fillRect(textBox.x,textBox.y,textBox.width,textBox.height);
          g.setColor(termColor);
          if (drawFlag) g.drawRect(textBox.x,textBox.y,textBox.width,textBox.height);
       }
       if (hiLight) {
          g.setColor(new Color(0,255,0));
          g.fillRect(textBox.x,textBox.y,textBox.width,textBox.height);
          g.setColor(termColor);
       }
       g.drawString(theTerm,textBox.x+3,fm.getAscent()+2+textBox.y);

       drawProducts(g); // override for other methods for drawing products and hooks
    }

    void drawProducts(Graphics g) { // override for other methods for drawing products and hooks
       //Set up stuff for storing lines - for now only if selected
       LineObject l = new LineObject();
       boolean select = isSelected();
       if (select) lineVector.setSize(0);

       int sourceSlots = 0, receptorSlots=0;
       int malef = 0; int femalef = 0; int receptors=0;
       boolean drawSpouse = false;
       // draw tabs, lines and receptors
       for(int i=0;i<products.size();i++) {
          Product p = ((Product) products.elementAt(i));
          int arrowType = p.getArrowType(); // the gender marked arrow type
          int cor=0; // used to move neutral source to left
          sourceSlots |= arrowType; // collect the set of arrows for this kin term entry
          Point startp = newHooks[arrowType].getLocation(); // the start point for drawing lines
          int gsex,gssex; // the gender and normalised gender
          gsex = gssex = p.getGenerator().getSubSex(); // initialise
                                                 //System.out.println(" the orientation "+this.orientation);
          Color genColour = sexColours[gsex]; // get colour for drawing
          gsex++; // shift values right
          if (gsex == 4) gsex = 0; // correct for undefined after assigning colour
          cor = 0; // initialise correction for neutral gender box placment
          switch (gsex) {
             case 1 : malef |= (1 >> p.getOrientation());break;
             case 2 : malef |= (1 >> p.getOrientation()); // fall through
                cor = -NOFFSET; // for neutral case use male boxes
                startp = newHooks[arrowType+cor].getLocation();
             case 3 : femalef |= (1 >> p.getOrientation());break;
          }
          Rectangle r = newHooks[arrowType+cor];
          g.setColor(setRectColor(genColour,arrowType));//color of rects
             if (gsex != 0) {
                if (p.getOrientation() == SPOUSE || p.getOrientation() == SPOUSE+1) {
                   if (gssex == subSex || gssex == 1 || gssex == 3 || subSex == 1) {
                      g.drawString("=",r.x+1,r.y+r.height-3);
                      drawSpouse = true;
                   }
                } else  {
                   if (drawFlag)
                      g.fillRect(r.x,r.y,r.width-5,r.height-5);
                }
             }
             g.setColor(setTabColor(genColour,arrowType));//color of hooks
                                                 //System.out.println("gencolor"+genColour+" at "+arrowType+ " subSex "+subSex);

                if (gsex != 0 && (gssex == subSex || gssex == 1 || gssex == 3 || subSex == 1) &&
        !(p.getOrientation() == SPOUSE || p.getOrientation() == SPOUSE+1)) { // what about my sex == neutral?????????
                   receptorSlots |= (1 << (inverseHook[p.getOrientation()]*2));

                   cor=0;
                   if (arrowType >= FOFFSET) cor = -NOFFSET;
                   else if (arrowType < NOFFSET) cor = NOFFSET;
                   Rectangle q=newHooks[inverseHook[arrowType+cor]];
                   if (drawFlag)
                      g.fillOval(q.x,q.y,q.width,q.height);
                   receptors |= (1 << inverseHook[p.getOrientation()]);


                }

                startp.translate(getLocation().x+HWIDTH/2,getLocation().y+HHEIGHT/2);
                KintermEntryVector kv = p.getTheLinks();
                for(int j=0;j<kv.size();j++) {

                   KintermEntry ke = kv.getSymbol(j);
                   ke.setFrom(this); // this probably only needs to be done on load...
                         // loadFile might be better location but need to
       // check maintenance when creating links like in
    // addProduct, where I have put support for this.
                   if (ke.coveredTerms != null) {
                      if (ke.isCovered.isFalse()) {
                         continue;
                      }
                   } else if (ke.coveringTerm != null) {
                      if (ke.isCovered.isTrue()) {
                         ke = (KintermEntry) ke.coveringTerm;
                      }
                   }
                   cor = 0;
                   if (arrowType >= FOFFSET+NOFFSET) cor = -FOFFSET;
                   else if (arrowType >= FOFFSET) cor = -NOFFSET;
                   else if (arrowType < NOFFSET) cor = NOFFSET;

                   Point tohook = ke.newHooks[inverseHook[arrowType+cor]].getLocation();
                   tohook.translate(ke.getLocation().x+HWIDTH/2,ke.getLocation().y+HHEIGHT/2);
                   //genColour = setArrowColor(genColour,arrowType);
                   l = new LineObject();
                   l.setKinterm(ke);
                   l.setProduct(p);
                   l.setStartPoint(startp);
                   l.setEndPoint(tohook);
                   l.setColour(setArrowColor(genColour,arrowType));//set arrow color
                                                       //               ((KinTermEditor)getParent()).drawTermLine(l);
                      l.setHasArrow(true);
                      if (p.getOrientation() == SPOUSE || p.getOrientation() == SPOUSE+1) {
                         l.setHasSpouseArrow(true);
                         l.setOffset(gssex);
                      }
                      if (select) {
                         l.paintSelected(((KinshipTermsPanel)getParent()).getGraphicsx());
                         lineVector.addElement(l);
                      }
                      l.paint(((KinshipTermsPanel)getParent()).getGraphicsx());
                      //System.out.println("Painting!!!!!!!!");
                }

                
       }

       g.setColor(Color.black);
       if (drawFlag)
          for (int j=0;j<4;j++) {
             int mask = 1 << j;
             if ((mask & malef) == 0 && (mask & femalef) == 0 && (mask & receptors) == 0)
                g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
             else if ((mask & malef & femalef) != 0) {
                if ((receptors & mask) == 0)
                   g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
             } else if ((mask & malef) != 0) {
                if ((receptors & mask) == 0)
                   g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
                else
                   g.drawOval(newHooks[j+FOFFSET].x,newHooks[j+FOFFSET].y,newHooks[j+FOFFSET].width,newHooks[j+FOFFSET].height);
             } else if ((mask & femalef) != 0) {
                if ((receptors & mask) == 0)
                   g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
                else
                   g.drawOval(newHooks[j].x,newHooks[j].y,newHooks[j].width,newHooks[j].height);
             }
             if (!drawSpouse) {
                g.drawString("=",newHooks[SPOUSE+NOFFSET].x+1,newHooks[SPOUSE+NOFFSET].y+newHooks[SPOUSE+NOFFSET].height-3);
             }
          }
   }


        Vector lineVector = new Vector(3);

        public LineObject searchLines(int x, int y) {
            LineObject l;
         for (int i=0;i<lineVector.size();i++) {
                l = (LineObject) lineVector.elementAt(i);
                if (l.inside(x,y)) {
                //  System.out.println("Inside Line");
                    return l;
                }
            }
            return null;
        }
        /**
     *This paint is for reduced views. Draws lines between the different members of KintermEntry in the same Container by calling
     * a routine in the parent Container, which must conform to Interface KintermEditor. These lines thus
     * exist in the parent coordinate space.
     * @param g the specified Graphics window
     * @see   java.awt.Component#update(java.awt.Graphics)
     */
 /*   public void paint_r(Graphics g) {
        if (coveredTerms != null) {
            if (isCovered.isFalse()) {
                hide();
                return;
            } else show();
        } else if (coveringTerm != null) {
            if (isCovered.isTrue()) {
                hide();
                return;
            } else show();
        }
        super.paint(g);

        g.setFont(itsFont);
        setRectangles(g);
        FontMetrics fm = g.getFontMetrics();
        //super.paint(g);
        g.drawRect(textBox.x,textBox.y,textBox.width,textBox.height);

        g.setColor(sexColours[subSex]);
        g.drawString(theTerm,textBox.x+3,fm.getAscent()+2+textBox.y);

        LineObject l = new LineObject();
        int sourceSlots = 0, receptorSlots=0;
        int malef = 0; int femalef = 0; int receptors=0;
        boolean drawSpouse = false;
    // draw tabs, lines and receptors
        for(int i=0;i<products.size();i++) {
            Product p = ((Product) products.elementAt(i));
            int arrowType = p.getArrowType(); // the gender marked arrow type
            int cor=0; // used to move neutral source to left
            sourceSlots |= arrowType; // collect the set of arrows for this kin term entry
            Point startp = newHooks[arrowType].getLocation(); // the start point for drawing lines
            int gsex,gssex; // the gender and normalised gender
            gsex = gssex = p.getGenerator().getSubSex(); // initialise
            Color genColour = sexColours[gsex]; // get colour for drawing
            gsex++; // shift values right
            if (gsex == 4) gsex = 0; // correct for undefined after assigning colour
            cor = 0; // initialise correction for neutral gender box placment
            switch (gsex) {
                case 1 : malef |= (1 >> p.getOrientation());break;
                case 2 : malef |= (1 >> p.getOrientation()); // fall through
                        cor = -NOFFSET; // for neutral case use male boxes
                        startp = newHooks[arrowType+cor].getLocation();
                case 3 : femalef |= (1 >> p.getOrientation());break;
            }
            Rectangle r = newHooks[arrowType+cor];

            g.setColor(genColour);
            if (gsex != 0) {
                if (p.getOrientation() == SPOUSE || p.getOrientation() == SPOUSE+1) {
                    if (gssex == subSex || gssex == 1 || gssex == 3 || subSex == 1) {
                        g.drawString("=",r.x+1,r.y+r.height-3);
                        drawSpouse = true;
                    }
                } else  {
                    g.fillRect(r.x,r.y,r.width-5,r.height-5);
                }
            }
            if (gsex != 0 && (gssex == subSex || gssex == 1 || gssex == 3 || subSex == 1) &&
                    !(p.getOrientation() == SPOUSE || p.getOrientation() == SPOUSE+1)) { // what about my sex == neutral?????????
                receptorSlots |= (1 << (inverseHook[p.getOrientation()]*2));

                cor=0;
                if (arrowType >= FOFFSET) cor = -NOFFSET;
                else if (arrowType < NOFFSET) cor = NOFFSET;
                Rectangle q=newHooks[inverseHook[arrowType+cor]];
                g.fillOval(q.x,q.y,q.width,q.height);
                receptors |= (1 << inverseHook[p.getOrientation()]);


            }

            startp.translate(getLocation().x+HWIDTH/2,getLocation().y+HHEIGHT/2);
            KintermEntryVector kv = p.getTheLinks();

            for(int j=0;j<kv.size();j++) {

                KintermEntry ke = kv.getSymbol(j);
                if (ke.coveredTerms != null) {
                    if (ke.isCovered.isFalse()) {
                        continue;
                    }
                } else if (ke.coveringTerm != null) {
                    if (ke.isCovered.isTrue()) {
                        ke = (KintermEntry) ke.coveringTerm;
                    }
                }
                cor = 0;
                if (arrowType >= FOFFSET+NOFFSET) cor = -FOFFSET;
                else if (arrowType >= FOFFSET) cor = -NOFFSET;
                else if (arrowType < NOFFSET) cor = NOFFSET;

                Point tohook = ke.newHooks[inverseHook[arrowType+cor]].getLocation();
                tohook.translate(ke.getLocation().x+HWIDTH/2,ke.getLocation().y+HHEIGHT/2);
                l.setStartPoint(startp);
                l.setEndPoint(tohook);
                l.setColour(genColour);
//              ((KinTermEditor)getParent()).drawTermLine(l);
                l.setHasArrow(true);
                if (p.getOrientation() == SPOUSE || p.getOrientation() == SPOUSE+1) {
                    l.setHasSpouseArrow(true);
                    l.setOffset(gssex);
                }
                l.paint(((KinshipTermsPanel)getParent()).getGraphicsx());
            }
        }

        g.setColor(Color.black);
        for (int j=0;j<4;j++) {
            int mask = 1 << j;
            if ((mask & malef) == 0 && (mask & femalef) == 0 && (mask & receptors) == 0)
                g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
            else if ((mask & malef & femalef) != 0) {
                if ((receptors & mask) == 0)
                    g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
            } else if ((mask & malef) != 0) {
                if ((receptors & mask) == 0)
                    g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
                else
                    g.drawOval(newHooks[j+FOFFSET].x,newHooks[j+FOFFSET].y,newHooks[j+FOFFSET].width,newHooks[j+FOFFSET].height);
            } else if ((mask & femalef) != 0) {
                if ((receptors & mask) == 0)
                    g.drawOval(newHooks[j+NOFFSET].x,newHooks[j+NOFFSET].y,newHooks[j+NOFFSET].width,newHooks[j+NOFFSET].height);
                else
                    g.drawOval(newHooks[j].x,newHooks[j].y,newHooks[j].width,newHooks[j].height);
            }
            if (!drawSpouse) {
                g.drawString("=",newHooks[SPOUSE+NOFFSET].x+1,newHooks[SPOUSE+NOFFSET].y+newHooks[SPOUSE+NOFFSET].height-3);
            }
        }
    }
*/

    /** the local rectangle where the term text is displayed
    */
    Rectangle textBox=new Rectangle(); // , maleBox=new Rectangle(), femaleBox=new Rectangle(), neutralBox=new Rectangle();
    /** assorted rectangels that define the location of where lines connecting terms can be originated and terminated.
    */
    Rectangle topHook=new Rectangle(), bottomHook=new Rectangle(),
        leftHook=new Rectangle(), rightHook=new Rectangle(),
        spouseHook = new Rectangle(),spouseHookR = new Rectangle();
    /** convenience array to allow conversion between source and destination hooks. Check for orientation=NONE
    * before using!!!!!
    */
    int inverseHook[] = {1,0,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24};

    /**  routine to locate the various hook widgets on the terms border
    @param g the Graphics context to do the FontMetrics. Possibly change in future to send FontMetrics instead.
    */
     void setRectangles(Graphics g) {
        FontMetrics fm = g.getFontMetrics();
        int swid = fm.stringWidth(theTerm)+4;
        int sht = fm.getHeight()+2;
        int vOffset = 12;
        int hOffset = 12;

        if ((hOffset+hOffset+swid+1) < (5*HWIDTH+14)) swid += (5*HWIDTH+14) -( hOffset+hOffset+swid+1);
        textBox.setBounds(hOffset,vOffset,swid,sht);
        setSize(new Dimension(hOffset+hOffset+swid+1,sht+vOffset+vOffset+2));

        int wid = getBounds().width;
        int ht = getBounds().height;
        int j = 0;
        int wido = HWIDTH/2;
        int hto = HHEIGHT/2;
        int off=0;

        for (int i=0;i<3;i++,off = i * NOFFSET) {
            newHooks[j+off].setLocation(wid/2+(i-1)*14-wido,i == 1 ? 2 : 6);
        }
        j=1;off=0;
        for (int i=0;i<3;i++,off = i * NOFFSET) {
            newHooks[j+off].setLocation(wid/2+(2 - i-1)*14-wido,ht-HHEIGHT- (i == 1 ? 3 : 2));
        }
        j=2;off=0;
        for (int i=0;i<3;i++,off = i * NOFFSET) {
            newHooks[j+off].setLocation(wid-11,ht/2+(i-1)*HHEIGHT-hto);
        }
        j=3;off=0;
        for (int i=0;i<3;i++,off = i * NOFFSET) {
            newHooks[j+off].setLocation(0,ht/2+(2 -i-1)*HHEIGHT-hto);
        }
        j=4;off=0;
        for (int i=0;i<3;i++,off = i * NOFFSET) {
            newHooks[j+off].setLocation(0,0);
            newHooks[j+off+1].setLocation(0,0);
        }
        for (int i=0;i<ORIENTATIONS.length;i++) {
            newHooks[FOFFSET+NOFFSET+i] = newHooks[NOFFSET+i]; // copy the neutral locations for undefined
        }



        topHook.setBounds(wid/2-5,0,10,10);
        bottomHook.setBounds(wid/2-5,ht-12,10,10);
        rightHook.setBounds(wid-11,ht/2-5,10,10);
        leftHook.setBounds(0,ht/2-5,10,10);
        spouseHook.setBounds(0,0,10,10);
        spouseHookR.setBounds(0,0,10,10);
}
    /** array of starting hooks
    */
    Rectangle[] theHooks = {topHook,bottomHook,rightHook,leftHook,spouseHook,spouseHookR,new Rectangle(0,0,0,0),new Rectangle(0,0,0,0),new Rectangle(0,0,0,0)}; // must change when change ORIENTATIONS array in KintermEditObject
    Rectangle[] newHooks = new Rectangle[inverseHook.length];
    /** male offsets for top, bottom, right and left
    */
    final static int TOPM = 0;
    final static int BOTM = 1;
    final static int RIGHTM = 2;
    final static int LEFTM = 3;
    final static int SPOUSEM = 4;
    /** height and width of hook rectangles
    */
    final static int HHEIGHT = 9;
    final static int HWIDTH = 9;
    /** add MOFFSET to get males
    * Must always be an even number to keep inverseHooks aligned.
    */
    final static int NOFFSET = 6;
    /** add FOFFSET to get females
    */
    final static int FOFFSET = 12;

    /** are we in a hook
    @returns UP, DOWN, RIGHT, LEFT, NONE
    */
    int whatHook(int x, int y) {
        int i;
        for(i=0;i<ORIENTATIONS.length;i++) if (theHooks[i].contains(x,y)) break;
        //System.out.println("Hook ="+i);
        if (i == ORIENTATIONS.length) return NONE;
        else return i;
    }
    int whatHookReceptor(int x, int y) {
        int i;
        for(i=ORIENTATIONS.length-1;i>=0;i--) if (theHooks[i].contains(x,y)) break;
        if (i < 0) return NONE;
        else return i;
    }

    int whatHook2(int x, int y) {
        int i;
        for(i=0;i<newHooks.length;i++) if (newHooks[i].contains(x,y)) return i;
        return NONE;
    }

    /** the kinship term. Defaults to "Click to enter kin term".
    */
    protected String theTerm="Click to enter kin term";
    /** The sex or gender associated with the term. M, F and N are valid choices. Defaults to N.
    */
    protected String sex="N";
    /** indicates which sex the string translates to
    */
    protected int subSex = UNDEFINED;

    final static int MALE = 0;
    final static int FEMALE =2;
    final static int NEUTRAL = 1;
    final static int UNDEFINED = 3;
    /** is this a  generating term?
    */
    /** colours for sex colouring; blue = male, red = female, orange = female,sibling,green = male,sibling
    */
    Color[] sexColours = {Color.blue,Color.gray,Color.red,Color.orange,Color.green,Color.black};

    public Color getSexColour(int sex) {
        return sexColours[sex];
    }
    protected boolean generating;
//  /** small font used for labelling. Probably not now used.
//  */
//  protected Font itsSmallFont = new Font("Helvetica",Font.BOLD,10);
    /** Font to display the term in.
    */
    protected Font itsFont = new Font("Times",Font.PLAIN,12);

    class SymMouse extends java.awt.event.MouseAdapter
    {
        public void mousePressed(java.awt.event.MouseEvent event)
        {
            Object object = event.getSource();
            if (object == KintermEntry.this)
                KintermEntry_MousePressed(event);
        }

        public void mouseReleased(java.awt.event.MouseEvent event)
        {
            Object object = event.getSource();
            if (object == KintermEntry.this)
                KintermEntry_MouseReleased(event);
        }
    }

    /** finds a KintermEntry term in the same Container that contains Point p. p is in Parent coordinates
    * @param p The point used to locate ithe KintermEntry
    * @returns a KintermEntry or null if not found
    */
    public KintermEntry findTerm(Point p) {
        Component c[] = getParent().getComponents();
        for (int i=0;i<c.length;i++) {
            if (c[i] instanceof KintermEntry) {
                if (c[i].getBounds().contains(p)) return (KintermEntry) c[i];
            }
        }
        return null;
    }

/** finds a KintermEntry term in the same Container that has name X.
* @param name The string used to locate ithe KintermEntry
* @returns a KintermEntry or null if not found
*/
public KintermEntry findTerm(String name) {
    Component c[] = getParent().getComponents();
    for (int i=0;i<c.length;i++) {
        if (c[i] instanceof KintermEntry) {
            if (((KintermEntry) c[i]).getTheTerm().equals(name)) return (KintermEntry) c[i];
        }
    }
    return null;
}


    public boolean isSelected() {
        return ((KinTermEditor) getParent()).getSelected() == this;
    }


    public void doSelect() {
//      if (!isSelected())
        ((KinTermEditor) getParent()).select(this);
        ((KinTermEditor) getParent()).repaint();
        //else ((KinTermEditor) getParent()).updateSelected();
    }

    public void clearSelected() {
        ((KinTermEditor) getParent()).clearSelected();
    }


    /** code for mouse released. Here, arbitrates between clicking on the text box, which indicates
    * a request to edit the text and set parameters, ignore the release (after clearing a few variables)
    * after dragging the component around the container, and terminating a line that has been drawn to
    * indicate a relationship.
    * @param event The mouse event.
    * @see other mouse stuff
    */
    void KintermEntry_MouseReleased(java.awt.event.MouseEvent event)
    {
        // to do: code goes here.

        //{{CONNECTION
        // Set the cursor CROSSHAIR_CURSOR
        if (textBox.contains(event.getX(), event.getY())) {
            if (wasDrug) {
                wasDrug = false;
                                if (kOver != null) {
                                    if (kOver.isVisible()) { // only visible components
                                        kOver.hilight(false);
                                        ((KinshipTermsPanel) getParent()).coverTerms(this,kOver);
                                        return;
                                    }
                                }
                doSelect();
                getParent().repaint();
            } else if (isSelected()) {
                ((KinTermEditor) getParent()).editKinterm(this);
            } else {
                doSelect();
            }
        } else {
            doSelect();
            if (whatHook(sx,sy) != -1) {
                int gx = this.getBounds().x;
                int gy = this.getBounds().y;
                int ex = event.getX() + gx;
                int ey = event.getY() + gy;
                gx += sx;
                gy += sy;
                KintermEntry k = findTerm(new Point(ex,ey));
                if (k != null && k.isCovered.isFalse()) {
                    Point l = k.getLocation();
                    int th = k.whatHookReceptor(ex-l.x,ey-l.y);
                    System.out.println("OtherHook="+th);
                    if (th != -1) {
                        if ((th^lhook) == 1) {
                            System.out.println("Current Gen="+currentGenerator+"target term="+  k);

                            ListVector genList = findPossibleGenerators(lhook,k);
                            if (genList.size()>0) {
                                k.setFrom(this);
                                try {
                                for (genList.reset();genList.isNext();) {
                                    setTo(k,(KintermEntry) genList.getNext(),lhook);
                                }
                                } catch (Exception e) {
                                    System.out.println("Generator="+genList.elementAt(genList.index).toString());
                                    System.out.println("GenList="+genList);
                                    System.out.println(e.getMessage());
                                    e.printStackTrace();
                                }
                                Graphics g = ((KinshipTermsPanel)getParent()).getGraphicsx();
                                g.setColor(theColour);
                                g.setXORMode(Color.green);
                                g.drawLine(lgx, lgy, lex, ley);
                                g.setPaintMode();
                                k.invalidate();
                                k.repaint();
                                repaint();
                            } else System.out.println("KintermEntry_MouseReleased: No generator found to link.");
                        }
                    }
                } else getParent().repaint();
            } else {

            }
        }
        setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
        sx = -1;
        sy = -1;
        lex = -10000;
        wasDrug = false;
        lhook = NONE;
        // ((KinshipTermsPanel)getParent()).updateKintable();
        //}}
    }

    class SymMouseMotion extends java.awt.event.MouseMotionAdapter
    {
        public void mouseDragged(java.awt.event.MouseEvent event)
        {
            Object object = event.getSource();
            if (object == KintermEntry.this)
                KintermEntry_MouseDragged(event);
        }
    }

    /** local flag to indicate to the mouse release code that this component has been dragged
    */
    boolean wasDrug=false;

    /* local references to the last start and endpoints of lines drawn for the XOR operation */
    int lex=-10000, ley=-10000, lgx, lgy;
    /** last hook used. To ensure proper connection of lines to appropriate ends
    */
    int lhook = NONE;
    /** current generator. Not currently used
    */
    KintermEntry currentGenerator = kin;

    /** Code for mouse dragged. Here, arbitrates between dragging the component around the container, or
    * drawing a line that  indicates a relationship.
    * @param event The mouse event.
    * @see other mouse stuff
    */

    void KintermEntry_MouseDragged(java.awt.event.MouseEvent event)
    {
        // to do: code goes here.
        if (!isSelected()) doSelect();
        //{{CONNECTION
        if (textBox.contains(event.getX(), event.getY())) {
            wasDrug=true;
        }
        int hook;
        if ((hook = whatHook(sx,sy)) != NONE) {
            Graphics g = ((KinshipTermsPanel)getParent()).getGraphics();
            g.setColor(theColour);
            g.setXORMode(Color.green);
            if (lex != -10000) {
                g.drawLine(lgx, lgy, lex, ley);
                g.fillRect(lex- 5,ley-5,10,10);
            }
//          sx = theHooks[hook].getLocation().translate(getLocation().x,getLocation().y).x;
//          sy = theHooks[hook].getLocation().translate(getLocation().x,getLocation().y).y;
            int gx = this.getBounds().x;
            int gy = this.getBounds().y;
            int ex = event.getX() + gx;
            int ey = event.getY() + gy;
            gx += sx;
            gy += sy;
            g.drawLine(gx, gy, ex, ey);
            g.fillRect(ex- 5,ey-5,10,10);
            lex = ex; ley = ey; lgx = gx; lgy =gy;
            wasDrug=true;
            lhook = hook;
            // when add tabs, set generating term currentGenerator
        } else if (sx != -1 && sy != -1) {
            int kx, ky;
            int dx = (kx = event.getX()) - sx;
            int dy = (ky = event.getY()) - sy;
            Point l = getLocation();
            l.translate(dx,dy);
            // setLocation(kx,ky);
            setLocation(l);
                        lkOver=kOver;
                        kOver = intersectOthers();
                        if (kOver != null) {
                            
                            kOver.hilight(true);
                        }
                        if (lkOver != kOver && lkOver != null) lkOver.hilight(false);
            ((KinTermEditor)getParent()).updateSelected();

                        // Code to do a merge when over a term
                        //((KinTermEditor)getParent()).
            //sx = kx;
            //sy = ky;
            // need this to clean up display
        //  counter++;
        //  if (counter > 4) {
        //      counter = 0;
        //      getParent().repaint();
        //  }
        }

        //}}
    }
    //int counter=0;
KintermEntry kOver=null, lkOver=null;

boolean hiLight=false;

public void hilight(boolean t) {
    hiLight = t;
   // Graphics g = getGraphics();
   // g.setColor(new Color(128,0,0));
  //  g.fillRect(textBox.x,textBox.y,textBox.width,textBox.height);
}

public KintermEntry intersectOthers() {
    getParent().invalidate();
    Component c[] = getParent().getComponents();
    for (int i=0;i<c.length;i++) {
        if (c[i] == (Component) this) continue;
        if (c[i] instanceof KintermEntry) { // patch up if changed!!!!!!!!!!!!!!!!!!!!!
            KintermEntry ke = (KintermEntry) c[i];
            if (ke.getBounds().intersects(getBounds()))
                if (ke.isVisible())
                    return ke;
        }
    }
    return null;
}

/** the x coordinate when the mouse was first pressed. Used by mouse drag and release code.
*/
int sx = -1;
/** the y coordinate when the mouse was first pressed. Used by mouse drag and release code.
*/
int sy = -1;

    /** Code for mouse pressed. Here, arbitrates between clicking in the text, (indicating an edit to release)
    * indicating that we want to drag the component around the container, or
    * indicate we want to drawa line that  indicates a relationship.
    * @param event The mouse event.
    * @see other mouse stuff
    */

    void KintermEntry_MousePressed(java.awt.event.MouseEvent event)
    {
        // to do: code goes here.

        //{{CONNECTION
        sx = event.getX();
        sy = event.getY();
    //  if (!isSelected()) doSelect(); // clear Selection of other component
        //}}
    }

    /** place to put generating term/destinations
    */
    ProductVector products = new ProductVector(3);
    /** place to put terms that link to us
    */
    KintermEntryVector from = new KintermEntryVector(3);

    /** a generic KintermEntry for initial use. It does not create valid relationships, but
    * allows the user to define the basic layout before beginning to allocating generating
    * terms that will be used to associate with the lines
    */
    static KintermEntry kin = new KintermEntry("Kin",true);

    public int isProduct(KintermEntry gt) {
        return isProduct(gt,0);
    }

    public int isProduct(KintermEntry gt, int arrow) {
        int i;
        Product p = new Product();
        p.setGenerator(gt);
        p.setOrientation(arrow);
        for(i=0;i<products.size();i++) {
            if (((Product) products.elementAt(i)).equals(p)) return i;
        }
        return -1;
    }

    void setTo(KintermEntry k, KintermEntry g, int arrow) {
        addProduct(g,k,arrow);
    }


    public void addProduct(KintermEntry gt, KintermEntry pr, int arrow) {
        int i;
        Product mm=null;
        Product p = new Product();
        // System.out.println("gt sex="+gt.getSex());
        // ALERT!!! hardwired sex below ... bad bad bad
        if (gt.getSubSex() == 3 && products.size() > ORIENTATIONS.length) {
            for(i=ORIENTATIONS.length;i<products.size();i++) {
                if ((mm = products.getSymbol(i)).getOrientation() == arrow && (mm.getSex() == pr.getSubSex() ||
                        mm.getSex() == 1 || pr.getSubSex() == 1)) break;
            }
            if (i<products.size()) {
                p = mm;
            } else {
                p = products.getSymbol(arrow); // artifactual !!!!!
            }
        } else {
            p.setGenerator(gt);
            p.setOrientation(arrow);

            for(i=0;i<products.size();i++) {
                if (products.getSymbol(i).equals(p)) break;
            }

            if (i < products.size()) {
                p = products.getSymbol(i);
            //  System.out.println("first if");
            } else {
             //   System.out.println("second if");
                if (products.size() < ORIENTATIONS.length)  products.addElement(p);
                else System.out.println("Error in addproduct ... generator not found = "+gt.toString());
                // products.addElement(p);
            }
        }
        if (pr != null) {
            KintermEntryVector tl = p.getTheLinks();
            if (tl.indexOf(pr) == -1) tl.addElement(pr);
            pr.setFrom(this);
        }
    }

/** makes list of terms that reference this term
    *   @param k The term that references us
**/
    void setFrom(KintermEntry k) {
        if (from.indexOf(k) == -1) from.addElement(k);
    }

/** removes a term from the set of links from this term
    *   @param k The term to remove
**/
    public void removeTerm(KintermEditObject k) {
            for(int i=0;i<products.size();i++) {
                Product p = (Product) products.elementAt(i);
                KintermEntryVector tl = p.getTheLinks();
                if (tl.indexOf(k) != -1) tl.removeElement(k);
            }
          k.removeFrom(this);
    }

/** removes a term and product from the set of links from this term
    *   @param k The term to remove
    * @param prod The product
**/
    public void removeTerm(KintermEditObject k, Product prod) {
            for(int i=0;i<products.size();i++) {
                Product p = (Product) products.elementAt(i);
                if (p.equals(prod)) {
                    KintermEntryVector tl = p.getTheLinks();
                    if (tl.indexOf(k) != -1) tl.removeElement(k);
                     if (countTo(k) < 1) k.removeFrom(this);
                }
            }
    }

public int countTo(KintermEditObject k) {
        int count=0;
        for(int i=0;i<products.size();i++) {
                Product p = (Product) products.elementAt(i);
                KintermEntryVector tl = p.getTheLinks();
                if (tl.indexOf(k) != -1) count++;
            }
            return count;
}
/** removes a term from the set of links from this term
    *   @param k The term to remove
**/
/*  public void removeTerm(KintermEntry k) {
                System.out.println("Ref: "+k.toString());
                for(int i=0;i<products.size();i++) {
                Product p = (Product) products.elementAt(i);
                KintermEntryVector tl = p.getTheLinks();
                    for(int j=tl.size()-1;j>=0;j--) {
                        System.out.println("To: "+tl.elementAt(j).toString());
                    }
                if (tl.indexOf(k) != -1) tl.removeElement(k);
            }
            k.removeFrom(this);
    }
*/
/*  public void removeFrom(KintermEntry k) {
        for(int i=from.size()-1;i>=0;i--) {
            System.out.println("From: "+from.elementAt(i).toString());
            if (from.indexOf(k) != -1) from.removeElement(k);
        }
    }
*/
    public void removeFrom(KintermEditObject k) {
        for(int i=from.size()-1;i>=0;i--) {
            System.out.println("From: "+from.elementAt(i).toString());
            if (from.indexOf(k) != -1) from.removeElement(k);
        }
    }
/** removes all references to this term as a generator or link
**/
    public void delete() {
        deleteThisAsGenerator();
        if(coveredTerms != null) {
            StringVector sv = coveredTerms;
            for (int i=0;i<sv.size();i++) {
                String s = sv.getSymbol(i);
                KintermEntry k = findTerm(s);
                if (k != null) {
                    k.isCovered.setFalse();
                    k.coveringTerm = null;
                    k.show();
                }
            }
        }
        if (coveringTerm != null) {
            KintermEntry k = findTerm((String)coveringTerm);
            if (k!=null) k.delete();
        }
        for(int i=from.size()-1;i>=0;i--) {
            // System.out.println("From: "+from.elementAt(i).toString());
            ((KintermEditObject)from.elementAt(i)).removeTerm(this);
        }
        removeTerm(this);
    }

/** sets the colour for this term
    *   @param theColour The colour to use
**/
    public void setTheColour(java.awt.Color theColour) {
        this.theColour = theColour;
    }

/** gets the colour used for this term
    *   @return theColour The colour used
**/
    public java.awt.Color getTheColour() {
        return theColour;
    }
    protected java.awt.Color theColour=Color.magenta;



    public int getOrientation() {
        return orientation;
    }

    protected int orientation=-1;

    public void setSubSex(int subSex) {
        this.subSex = subSex;
    }

    public int getSubSex() {
        return subSex;
    }
    /** need to check and make sure that this is compatible with the term reference switching
    * also that we are saving enough information
    */
    public TransferKinInfo toKinTermInfo() {
    //  TransferKinInfo(String t,  String s, boolean isgen, int orient, Point org)
        TransferKinInfo kt = new TransferKinInfo(theTerm, sex, generating,orientation,getLocation());
        if (coveringTerm != null) kt.coveringTerm = ((KintermEntry) coveringTerm).theTerm;
        else kt.coveringTerm = null;
        kt.coveredTerms = coveredTerms;
        kt.isCovered = isCovered;
        kt.products =  products.toList();
        kt.setEtc(this.isEtc());
        //kt.setDropMerge(dropMerge);
        kt.setTheVariables(getTheVariables());
        return kt;
    }

    public String toString() {
        return "KintermEntry: "+theTerm;
    }

    boolean firstTime = true;

    public boolean isFirstTime() {
        boolean x = firstTime;
        firstTime = false;
        return x;
    }

   StringVector coveredTerms = null;
   Object coveringTerm = null;
   BooleanSwitch isCovered = new BooleanSwitch(false);
  // boolean dropMerge = false;

   public void setIsCovered(BooleanSwitch b) {
      isCovered = b;
   }

public boolean isCovered() {
    return isCovered.isTrue();
}

   public void setCoveringTerm(String coveringTerm) {
      this.coveringTerm = coveringTerm;
   }
   
   public void setCoveredTerms(StringVector coveredTerms) {
      this.coveredTerms = coveredTerms;
   }

/*   public void setDropMerge(boolean dm) {
      this.dropMerge = dm;
   }
   
   public boolean isDropMerge() {
      return dropMerge;
   }
*/
    public void setEtc(boolean etc) {
        this.etc = etc;
    }

    public boolean isEtc() {
        return etc;
    }

protected boolean etc=false;

    public void setTheVariables(Variables theVariables) {
        this.theVariables = theVariables;
    }

    public Variables getTheVariables() {
        return theVariables;
    }
    protected Variables theVariables=new Variables();


    ListVector findPossibleGenerators(int arrow, KintermEntry k){
        ListVector retList = new ListVector();
        Product mm;
        for(int i=ORIENTATIONS.length;i<products.size();i++) {
            if ((mm = products.getSymbol(i)).getOrientation() == arrow &&
                (mm.getGenerator().getSex().equals(k.getSex()) ||
                k.getSex().equals("N") || mm.getGenerator().getSex().equals("N"))){
                    retList.addElement(mm.getGenerator());
            }
        }
        if (retList.size()==0) {
           System.out.println("!!!!! no generators found in findPossibleGenerators in KintermEntry");
        }

		return retList;
	}

}


