/* * @(#)QSortAlgorithm.java	1.3   29 Feb 1996 James Gosling * * Copyright (c) 1994-1996 Sun Microsystems, Inc. All Rights Reserved. * *//** * A quick sort demonstration algorithm * SortAlgorithm.java * * @author James Gosling * @author Kevin A. Smith * @version 	@(#)QSortAlgorithm.java	1.3, 29 Feb 1996 */ import java.util.*;public class QSort extends Object {   /** This is a generic version of C.A.R Hoare's Quick Sort     * algorithm.  This will handle arrays that are already    * sorted, and arrays with duplicate keys.<BR>    *    * If you think of a one dimensional array as going from    * the lowest index on the left to the highest index on the right    * then the parameters to this function are lowest index or    * left and highest index or right.  The first time you call    * this function it will be with the parameters 0, a.length - 1.    *    * @param a       an integer array    * @param lo0     left boundary of array partition    * @param hi0     right boundary of array partition    */  	   int[] QuickSort(String a[], int lo0, int hi0, int[] indicies) throws Exception   {      int lo = lo0;      int hi = hi0;      String mid;	  	  if (indicies == null) {	 	 indicies = new int[a.length];	 	 for(int i=0;i<a.length;i++) indicies[i] = i; // reference array to know true order in list;      }      // pause for redraw     //  pause(lo, hi); // no more !      if ( hi0 > lo0)      {         /* Arbitrarily establishing partition element as the midpoint of          * the array.          */         mid = a[ ( lo0 + hi0 ) / 2 ];         // loop through the array until indices cross         while( lo <= hi )         {            /* find the first element that is greater than or equal to              * the partition element starting from the left Index.             */            while( ( lo < hi0 ) && ( a[lo].compareTo(mid) < 0 ) )               ++lo;            /* find an element that is smaller than or equal to              * the partition element starting from the right Index.             */            while( ( hi > lo0 ) && ( a[hi].compareTo( mid ) > 0) )               --hi;            // if the indexes have not crossed, swap            if( lo <= hi )             {               swap(a, indicies, lo, hi);               // pause             //  pause();               ++lo;               --hi;            }         }         /* If the right index has not reached the left side of array          * must now sort the left partition.          */         if( lo0 < hi )            QuickSort( a, lo0, hi, indicies );         /* If the left index has not reached the right side of array          * must now sort the right partition.          */         if( lo < hi0 )            QuickSort( a, lo, hi0, indicies );      }      return indicies;   }   int[] QuickSort(float a[], int lo0, int hi0, int[] indicies) throws Exception   {      int lo = lo0;      int hi = hi0;      float mid;	  			if (indicies == null) {				indicies = new int[a.length];				for(int i=0;i<a.length;i++) indicies[i] = i; // reference array to know true order in list;			}			if ( hi0 > lo0) {				mid = a[ ( lo0 + hi0 ) / 2 ];         while( lo <= hi )  {            while( ( lo < hi0 ) && ( a[lo] >= mid )) ++lo;						while( ( hi > lo0 ) && ( a[hi] <= mid))  --hi;						if( lo <= hi )  {               swap(a, indicies, lo, hi);               ++lo;               --hi;            }				}				if( lo0 < hi ) QuickSort( a, lo0, hi, indicies );				if( lo < hi0 ) QuickSort( a, lo, hi0, indicies );      }      return indicies;   }  int[] QuickSortN(Vector a, int lo0, int hi0, int[] indicies) throws Exception   {      int lo = lo0;      int hi = hi0;      CompObj mid;	  			if (indicies == null) {				indicies = new int[a.size()];				for(int i=0;i<a.size();i++) indicies[i] = i; // reference array to know true order in list;			}			if ( hi0 > lo0) {				mid = new CompObj(a.elementAt (indicies[ (lo0 + hi0 ) / 2] ));         while( lo <= hi )  {            while( ( lo < hi0 ) && mid.gt(a.elementAt(indicies[lo]))) ++lo;						while( ( hi > lo0 ) && mid.lt(a.elementAt(indicies[hi]))) --hi;						if( lo <= hi )  {               swap(indicies, lo, hi);               ++lo;               --hi;            }				}				if( lo0 < hi ) QuickSortN( a, lo0, hi, indicies );				if( lo < hi0 ) QuickSortN( a, lo, hi0, indicies );      }      return indicies;   }   int[] QuickSort(Vector a, int lo0, int hi0, int[] indicies) throws Exception   {      int lo = lo0;      int hi = hi0;      String mid;	  	  if (indicies == null) {	 	 indicies = new int[a.size()];	 	 for(int i=0;i<a.size();i++) indicies[i] = i; // reference array to know true order in list;    }      if ( hi0 > lo0)      {         /* Arbitrarily establishing partition element as the midpoint of          * the array.          */         try {         mid = a.elementAt (indicies[ (lo0 + hi0 ) / 2] ).toString();         // loop through the array until indices cross         while( lo <= hi )         {            /* find the first element that is greater than or equal to              * the partition element starting from the left Index.             */            while( ( lo < hi0 ) && ( a.elementAt(indicies[lo]).toString().compareTo(mid) < 0 ) )               ++lo;            /* find an element that is smaller than or equal to              * the partition element starting from the right Index.             */            while( ( hi > lo0 ) && ( a.elementAt(indicies[hi]).toString().compareTo( mid ) > 0) )               --hi;            // if the indexes have not crossed, swap            if( lo <= hi )             {               swap(indicies, lo, hi);               // pause             //  pause();               ++lo;               --hi;            }         }					} catch (Exception e) {						e.printStackTrace();					}         /* If the right index has not reached the left side of array          * must now sort the left partition.          */         if( lo0 < hi )            QuickSort( a, lo0, hi, indicies );         /* If the left index has not reached the right side of array          * must now sort the right partition.          */         if( lo < hi0 )            QuickSort( a, lo, hi0, indicies );      }      return indicies;   }   private void swap(String a[], int[] ix, int i, int j)   {      String T;      int q;      		T = a[i]; 		a[i] = a[j];		a[j] = T;		q = ix[i];		ix[i] = ix[j];		ix[j] = q;   }   private void swap(float a[], int[] ix, int i, int j)   {      float T;      int q;      		T = a[i]; 		a[i] = a[j];		a[j] = T;		q = ix[i];		ix[i] = ix[j];		ix[j] = q;   }    private void swap(int[] ix, int i, int j)   {     int q;      		q = ix[i];		ix[i] = ix[j];		ix[j] = q;   }   public int[] sort(String a[]) throws Exception   {				return QuickSort(a, 0, a.length - 1, null);   }    public int[] sort(float a[]) throws Exception   {				return QuickSort(a, 0, a.length - 1, null);   }   public int[] sort(Vector a) throws Exception   {				return QuickSort(a, 0, a.size() - 1, null);   }    public int[] sortN(Vector a) throws Exception   {				return QuickSortN(a, 0, a.size() - 1, null);   }}class CompObj {	Object o=null;	int type=OTHER;	static final int DOUBLE=1;;	static final int INT=2;	static final int STRING=3;	static final int OTHER=0;		CompObj(Object x) {		o = x;		if (o instanceof Double) type=DOUBLE;		else if (o instanceof Integer) type=INT;		else if (o instanceof String) type=STRING;		else type=OTHER;	}	boolean lt(Object k) {		switch (type) {			case DOUBLE: return ((Double) o).doubleValue() < ((Double) k).doubleValue() ;			case INT: return ((Integer) o).intValue() < ((Integer) k).intValue() ;			case STRING: return ((String) o).compareTo((String) k) < 0 ;			case OTHER: 		return o.toString().compareTo(k.toString()) < 0 ;		}		return false;	}	boolean gt(Object k) {		switch (type) {			case DOUBLE: return ((Double) o).doubleValue() > ((Double) k).doubleValue() ;			case INT: return ((Integer) o).intValue() > ((Integer) k).intValue() ;			case STRING: return ((String) o).compareTo((String) k) > 0 ;			case OTHER: 		return o.toString().compareTo(k.toString()) > 0 ;		}		return false;	}	boolean ge(Object k) {		return !lt( k);	}	boolean le(Object k) {		return !gt( k);	}}
