#BlueJ class context
comment0.target=TransferKinInfoVector
comment0.text=\ History\r\n\ 3/10/01\ DR\ added\ the\ filter\ fProdAndTermSexComplement\ to\ get\ the\ complement\ of\ a\ specified\ sex\r\n\ 5/06\ DR\ added\ buildSet\ version\ that\ uses\ a\ focal\ term\ stringvector\ as\ an\ argument\r\n\ modified\ the\ definition\ of\ a\ focal\ term\r\n\ 5/29\ DR\ changed\ findFocalTerm\ to\ use\ effective\ terms\r\n\ 7/18\ DR\ added\ isEffectiveTerm(String\ term)\ to\ test\ if\ term\ is\ an\ effective\ term\r\n\ in\ the\ TransferKinInfoVector\r\n\ 7/27\ DR\ Added\ procedures\ theGeneration,\ theGenerations,\ computeGenerations()\r\n\ 8/3\ DR\ Added\ procedures\ checkCompletenessOfStructure(),\ checkProducts\ to\ see\ if\r\n\ kin\ terms\ products\ with\ generators\ have\ been\ defined\r\n\ 8/20\ DR\ added\ check\ for\ affinal\ term\ in\ findFocalTerms\ since\ focal\ terms\ are\ not\r\n\ affinal\ terms\ (otherwise\ Spouse\ in\ AKT\ would\ be\ a\ focal\ term)\r\n\ 9/1\ DR\ added\ getSex(String\ term)\ to\ get\ the\ sex\ of\ a\ kin\ term\r\n\ 10/2\ DR\ added\ procedure\ fDecompose(String\ tsex)\ to\ decompose\ covering\ terms\ into\r\n\ their\ constituent\ terms\ and\ then\ filter\ using\ tsex\r\n\ 10/6\ DR\ added\ procedure\ fDecompose(String\ tsex)\ to\ decompose\ merged\ terms\ into\ covered\ term\r\n\ of\ sex\ complement\ to\ tsex\r\n\ 1/24\ DR\ added\ test\ if\ (\!lookupTerm(lookupTerm(gen).getEffectiveTerm()).isAGenerator)\r\n\ \ \ \ \ \ \ \ \ \ \ p\ \=\ k.getProducts().getGenerator(gen);//covering\ term\ not\ a\ generator\r\n\ to\ procedure\ getEffectiveProducts\r\n\ Added\ code\ to\ isIdentityElement\ for\ case\ where\ A,B\ are\ gens\ but\ [A,B]\ is\ not\ a\r\n\ generator\r\n
comment1.params=s
comment1.target=TransferKinInfo\ lookupTerm(java.lang.String)
comment10.params=k
comment10.target=TransferKinInfo\ effectiveGenerator(TransferKinInfo)
comment11.params=
comment11.target=TransferKinInfo\ getNext()
comment12.params=
comment12.target=TransferKinInfo\ getNextEffectiveTerm()
comment13.params=term\ gen
comment13.target=StringVector\ getEffectiveProducts(java.lang.String,\ java.lang.String)
comment14.params=k\ gen
comment14.target=StringVector\ getEffectiveProducts(TransferKinInfo,\ java.lang.String)
comment15.params=k\ gen
comment15.target=StringVector\ getProducts(TransferKinInfo,\ java.lang.String)
comment16.params=termV\ arrows
comment16.target=TransferKinInfoVector\ buildSet(StringVector,\ int[])
comment17.params=term\ arrows
comment17.target=TransferKinInfoVector\ buildSet(java.lang.String,\ int[])
comment18.params=kinterm\ arrows\ h
comment18.target=void\ _buildSet(TransferKinInfo,\ int[],\ java.util.Hashtable)
comment19.params=deep
comment19.target=java.lang.Object\ clone(boolean)
comment2.params=
comment2.target=StringVector\ toStringVector()
comment20.params=
comment20.target=TransferKinInfoVector\ deepClone()
comment21.params=s
comment21.target=void\ setTitle(java.lang.String)
comment22.params=
comment22.target=java.lang.String\ getTitle()
comment23.params=
comment23.target=TransferKinInfoVector\ getGenerators()
comment23.text=\ get\ all\ generators\r\n\ \ \ \ @return\ list\ of\ generators\r\n
comment24.params=orientation
comment24.target=TransferKinInfoVector\ getGenerators(int)
comment24.text=\ get\ all\ generators\ of\ a\ given\ orientation\r\n\ \ \ \ @param\ orientation\ the\ constants\ that\ define\ the\ arrow\ orientation\ of\ the\ generator.\r\n\ \ \ \ @see\ ORIENTATION\r\n\ \ \ \ @return\ list\ of\ selected\ generators\r\n
comment25.params=
comment25.target=TransferKinInfoVector\ getEffectiveGenerators()
comment25.text=\ get\ all\ Effective\ generators\r\n\ \ \ \ Effective\ generators\ respect\ the\ status\ of\ covering\ and\ covered\ terms\ if\ the\ covered\ instance\r\n\ \ \ \ variable\ is\ set.\ Covering\ terms\ replace\ one\ or\ more\ other\ terms.\r\n\ \ \ \ @return\ list\ of\ effective\ generators\r\n
comment26.params=orientation
comment26.target=TransferKinInfoVector\ getEffectiveGenerators(int)
comment26.text=\ get\ all\ effective\ generators\ of\ a\ given\ orientation\r\n\ \ \ \ @param\ orientation\ the\ constants\ that\ define\ the\ arrow\ orientation\ of\ the\ generator.\r\n\ \ \ \ @see\ ORIENTATION\r\n\ \ \ \ @return\ list\ of\ selected\ generators\r\n
comment27.params=orientation\ sex
comment27.target=TransferKinInfoVector\ getEffectiveGenerators(int,\ java.lang.String)
comment27.text=\ get\ all\ effective\ generators\ of\ a\ given\ orientation\ and\ sex\r\n\ \ \ \ @param\ orientation\ the\ constants\ that\ define\ the\ arrow\ orientation\ of\ the\ generator.\r\n\ \ \ \ @param\ sex\ the\ sex\ of\ the\ generators\ to\ be\ returned\r\n\ \ \ \ @see\ ORIENTATION\r\n\ \ \ \ @return\ list\ of\ selected\ generators\r\n
comment28.params=
comment28.target=void\ delete()
comment28.text=\ delete\ the\ term\ currently\ pointed\ to\ by\ index\r\n
comment29.params=term
comment29.target=void\ delete(TransferKinInfo)
comment29.text=\ delete\ the\ term\r\n
comment3.params=
comment3.target=java.lang.String\ toXML()
comment30.params=tsex
comment30.target=TransferKinInfoVector\ fSex(java.lang.String)
comment30.text=\ filter\ out\ all\ kinterms\ not\ of\ sex\ tsex\r\n\ \ \ \ @param\ tsex\ the\ sex\ to\ keep\r\n\ \ \ \ @return\ the\ list\ of\ terms\ of\ sex\ tsex\r\n
comment31.params=
comment31.target=TransferKinInfoVector\ fGen()
comment31.text=\ filter\ out\ all\ kinterms\ that\ are\ not\ generators\r\n\ \ \ \ @return\ the\ list\ of\ terms\ that\ are\ generators\r\n
comment32.params=tsex
comment32.target=TransferKinInfoVector\ fGenSex(java.lang.String)
comment32.text=\ filter\ out\ all\ kinterms\ not\ of\ sex\ tsex\ and\ are\ not\ generators\r\n\ \ \ \ @param\ tsex\ the\ sex\ to\ keep\r\n\ \ \ \ @return\ the\ list\ of\ terms\ of\ sex\ tsex\ that\ are\ generators\r\n
comment33.params=tsex
comment33.target=TransferKinInfoVector\ fProdSex(java.lang.String)
comment33.text=\ filter\ out\ all\ kinterm\ products\ that\ are\ not\ of\ sex\ tsex\r\n\ \ \ \ @param\ tsex\ the\ sex\ to\ keep\r\n\ \ \ \ @return\ the\ list\ of\ terms\ and\ their\ products\ that\ are\ of\ sex\ tsex\r\n
comment34.params=tsex
comment34.target=TransferKinInfoVector\ fProdAndTermSexComplement(java.lang.String)
comment34.text=\ filter\ out\ all\ kinterm\ products\ and\ terms\ that\ are\ of\ sex\ tsex\r\n\ \ \ \ @param\ tsex\ the\ sex\ to\ remove\r\n\ \ \ \ @return\ the\ list\ of\ terms\ and\ their\ products\ that\ are\ not\ of\ sex\ tsex\r\n
comment35.params=tsex
comment35.target=TransferKinInfoVector\ fDecompose(java.lang.String)
comment35.text=\ replace\ covering\ term\ by\ the\ covered\ term\ for\ covered\ terms\r\n\ \ with\ sex\ the\ complement\ of\ tsex\r\n\ \ \ \ @param\ tsex\ the\ sex\ to\ remove\r\n\ \ \ \ @return\ the\ list\ of\ terms\ after\ covering\ terms\ have\ been\ replaced\r\n
comment36.params=arrow
comment36.target=TransferKinInfoVector\ fGenArrow(int)
comment36.text=\ filter\ out\ all\ generators\ that\ are\ not\ of\ orientation\ arrow\r\n\ \ \ \ @param\ arrow\ the\ orientation\ to\ keep\r\n\ \ \ \ @return\ the\ list\ of\ generators\ of\ orientation\ arrow\r\n
comment37.params=
comment37.target=TransferKinInfoVector\ fNoProductions()
comment37.text=\ Remove\ kin\ terms\ from\ the\ kin\ term\ map\ that\ have\ no\ active\ generators.\ As\ currently\ written,\r\n\ this\ may\ leave\ generator\ product\ references\ to\ the\ deleted\ term,\ so\ these\ should\ be\ pruned\r\n\ if\ necessary\!\ <br>\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment38.params=term
comment38.target=StringVector\ getInverse(java.lang.String)
comment38.text=\ Looks\ up\ a\ term\ in\ the\ inverse\ table\ to\ see\ what\ production\ the\ term\ appears\ in.\r\n
comment39.params=
comment39.target=void\ buildInverseTable()
comment39.text=\ Builds\ a\ hash\ table\ with\ the\ term\ as\ key\ and\ list\ of\ terms\ for\ which\ it\ is\ a\ generator\ productions.\r\n\ The\ table\ needs\ to\ be\ rebuilt\ whenever\ a\ significant\ change\ is\ made\ to\ the\ kin\ term\ map.\r\n
comment4.params=index
comment4.target=TransferKinInfo\ getSymbol(int)
comment40.params=gen\ focal
comment40.target=ListVector\ findReciprocals(java.lang.String,\ java.lang.String)
comment40.text=\ finds\ the\ reciprocal\ (if\ any)\ and\ reciprocal\ equation\r\n\ @param\ gen\ the\ generator\ in\ question\r\n\ @param\ focal\ a\ focal\ term\ of\ the\ kin\ term\ map\r\n\ @return\ a\ list\ of\ the\ equation(s),\ if\ any.\ Empty\ list\ implies\ none.\r\n
comment41.params=
comment41.target=TransferKinInfoVector\ fUpdateFromProductions()
comment41.text=\ Adds\ to\ this\ kin\ term\ map\ any\ missing\ kin\ terms\ referenced\ in\ its\ generator\ productions.\r\n\ Creates\ a\ kin\ term\ map\ that\ contains\ all\ kin\ terms\ referenced\ in\ its\ generation\ productions.\r\n\ ???It\ appears\ that\ this\ will\ not\ work\ if\ the\ tables\ have\ been\ rebuilt\ -\ \ @see\ buildtables().\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment42.params=
comment42.target=TransferKinInfoVector\ fUpdateFromTerms()
comment42.text=\ Removes\ from\ this\ kin\ term\ map\ any\ kin\ terms\ not\ referenced\ in\ its\ generator\ productions,\r\n\ \ \ \ or\ remove\ generator\ productions\ not\ in\ this\ kin\ term\ map.\r\n\ Creates\ a\ kin\ term\ map\ that\ contains\ only\ generation\ productions\ which\ are\ terms\ of\ this\ map.\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment43.params=
comment43.target=void\ buildTables()
comment43.text=\ (re-)builds\ the\ tables\ for\ the\ kin\ terms\r\n
comment44.params=termsToRemove
comment44.target=TransferKinInfoVector\ fRemove(java.util.Vector)
comment44.text=\ Remove\ kin\ terms\ from\ this\ kin\ term\ map.\r\n\ Creates\ a\ kin\ term\ map\ that\ does\ not\ contain\ the\ kin\ terms\ in\ <i>termsToRemove</i>.\r\n\ If\ these\ terms\ are\ not\ in\ the\ kin\ term\ map\ then\ it\ is\ unchanged.\ References\ to\ these\r\n\ terms\ are\ also\ removed\ from\ generator\ productions,\ as\ well\ as\ all\ productions\ associated\ with\r\n\ a\ generator\ included\ in\ the\ list.\r\n\ @param\ termsToRemove\ List\ of\ kin\ terms\ to\ be\ removed\ from\ this.\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment45.params=union
comment45.target=TransferKinInfoVector\ fUnion(TransferKinInfoVector)
comment45.text=\ Finds\ the\ union\ of\ this\ kin\ term\ map\ with\ another\r\n\ Creates\ a\ kin\ term\ map\ that\ contains\ all\ kin\ terms\ in\ <i>this</i>\r\n\ and\ the\ kin\ term\ map\ <i>union</i>.\ Note\ that\ the\ union\ only\ includes\ the\ set\ of\ productions\r\n\ currently\ in\ the\ two\ kin\ term\ maps.\ Use\ <i>fMerge</i>\ to\ restore\ cross\ references\ between\r\n\ the\ terms\ in\ the\ two\ maps\ that\ might\ have\ been\ lost\ in\ earlier\ transformations.\ <br>\r\n\ Only\ this\ kin\ term\ map\ will\ be\ altered.\ The\ parameter\ kin\ term\ map\ will\ never\ be\ changed.\r\n\ @param\ union\ The\ kin\ term\ map\ to\ be\ added\ to\ this.\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment46.params=diff
comment46.target=TransferKinInfoVector\ fDifference(TransferKinInfoVector)
comment46.text=\ Finds\ the\ difference\ of\ this\ kin\ term\ map\ with\ another\r\n\ Creates\ a\ kin\ term\ map\ that\ contains\ only\ kin\ terms\ in\ <i>this</i>\ that\ are\ not\ shared\r\n\ with\ the\ kin\ term\ map\ <i>diff</i>.\r\n\ This\ includes\ the\ difference\ of\ generator\ productions\ -\ only\ productions\ that\ are\ different\r\n\ are\ retained.\ <br>\r\n\ Only\ this\ kin\ term\ map\ will\ be\ altered.\ The\ parameter\ kin\ term\ map\ will\ never\ be\ changed.\r\n\ @param\ diff\ The\ kin\ term\ map\ to\ be\ removed\ from\ this.\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment47.params=intersect
comment47.target=TransferKinInfoVector\ fIntersection(TransferKinInfoVector)
comment47.text=\ Finds\ the\ intersection\ of\ this\ kin\ term\ map\ with\ another\r\n\ Creates\ a\ kin\ term\ map\ that\ contains\ all\ kin\ terms\ in\ <i>this</i>\ that\ are\ shared\ with\ <i>intersect</i>.\r\n\ This\ includes\ the\ intersection\ of\ generator\ productions\ -\ only\ productions\ that\ are\ in\ common\r\n\ are\ reported.\ <br>\r\n\ Only\ this\ kin\ term\ map\ will\ be\ altered.\ The\ parameter\ kin\ term\ map\ will\ never\ be\ changed.\r\n\ @param\ intersect\ The\ kin\ term\ map\ to\ be\ intersected\ with\ this.\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment48.params=merge\ unity
comment48.target=TransferKinInfoVector\ fMerge(TransferKinInfoVector,\ TransferKinInfoVector)
comment48.text=\ Merges\ this\ kin\ term\ map\ with\ another\r\n\ This\ merges\ by\ examining\ the\ original\ kin\ term\ map\ that\ both\ maps\ were\ derived\ from,\r\n\ and\ re-inserts\ generator\ productions\ for\ each\ map\ that\ include\ references\ to\ terms\ in\ the\r\n\ other\ map.\ The\ object\ is\ to\ produce\ a\ complete\ kin\ term\ map\ with\ respect\ to\ the\ included\r\n\ relationships.\ The\ results\ should\ be\ identical\ to\ a\ map\ that\ was\ created\ by\ removing\r\n\ terms\ that\ are\ in\ neither\ of\ the\ present\ kin\ term\ maps.\r\n\ Only\ this\ kin\ term\ map\ will\ be\ altered.\ The\ parameter\ map\ will\ never\ be\ changed.\r\n\ @param\ merge\ The\ kin\ term\ map\ to\ be\ merged\ into\ this.\r\n\ @param\ unity\ The\ original\ kin\ term\ map\ from\ which\ both\ this\ and\ <i>merge</i>\ were\ derived.\r\n\ @return\ The\ current\ kin\ map.\ This\ is\ a\ convenience\ so\ that\ the\ filters\ can\ be\ applied\ inline.\r\n
comment49.params=
comment49.target=StringVector\ getFocalTerms()
comment49.text=\ Returns\ the\ focal\ terms\r\n\ @return\ the\ focal\ terms\r\n
comment5.params=
comment5.target=void\ buildTable()
comment50.params=
comment50.target=StringVector\ getEffectiveFocalTerms()
comment51.params=sex
comment51.target=StringVector\ getEffectiveFocalTerms(java.lang.String)
comment52.params=
comment52.target=ListVector\ findStructuralEquivalents()
comment53.params=candidateSets
comment53.target=TransferKinInfoVector\ mergeGenerators(ListVector)
comment53.text=\tpublic\ ListVector\ findStructuralEquivalentsRelaxed()\ {\r\n\ \ \ \ TransferKinInfoVector\ tk\ \=\ deepClone();\r\n\ \ \ \ tk.fRemove(findFocalTerms());\r\n\ \ \ \ return\ tk.findStructuralEquivalents();\r\n\ \ \ \ }\r\n
comment54.params=candidates
comment54.target=TransferKinInfoVector\ mergeGenerators(TransferKinInfoVector)
comment55.params=candidates
comment55.target=TransferKinInfoVector\ mergeGenerators(StringVector)
comment55.text=\ Needs\ to\ be\ checked\ that\ having\ one\ or\ more\ invalid\ generators\ in\ conjuntion\ with\r\n\ a\ valid\ generator\ will\ not\ cause\ a\ problem\r\n
comment56.params=candidateSets
comment56.target=TransferKinInfoVector\ mergeTerms(ListVector)
comment57.params=candidateSets\ flag
comment57.target=TransferKinInfoVector\ mergeTerms(ListVector,\ boolean)
comment58.params=candidates
comment58.target=TransferKinInfoVector\ mergeTerms(TransferKinInfoVector)
comment59.params=candidates
comment59.target=TransferKinInfoVector\ mergeTerms(StringVector)
comment6.params=
comment6.target=void\ reset()
comment60.params=candidates\ dmerge
comment60.target=TransferKinInfoVector\ mergeTerms(StringVector,\ boolean)
comment61.params=term
comment61.target=boolean\ isIdentityTerm(java.lang.String)
comment61.text=\ Verifies\ if\ term\ is\ an\ identity\ element\ for\ this\ map,\r\n\ our\ expectations\ is\ that\ there\ will\ be\ only\ one\ that\ is\ non-gendered,\r\n\ and\ two\ in\ some\ cases\ where\ gendered\ (as\ in\ Tribriand\ terminology)\r\n\ @term\ term\ to\ verified\ as\ identity\ term\r\n
comment62.params=term
comment62.target=boolean\ isIdentityTerm(TransferKinInfo)
comment62.text=\ Verifies\ if\ term\ is\ an\ identity\ element\ for\ this\ map,\r\n\ our\ expectations\ is\ that\ there\ will\ be\ only\ one\ that\ is\ non-gendered,\r\n\ and\ two\ in\ some\ cases\ where\ gendered\ (as\ in\ Tribriand\ terminology)\r\n\ @term\ term\ to\ verified\ as\ identity\ term\r\n
comment63.params=term\ sex
comment63.target=boolean\ isIdentityTerm(TransferKinInfo,\ java.lang.String)
comment63.text=\ Verifies\ if\ term\ is\ an\ identity\ element\ for\ this\ map,\r\n\ with\ respect\ to\ generators\ of\ sex\ given\ by\ the\ parameter\ sex\r\n\ @sex\ test\ agains\ generators\ of\ sex\ given\ by\ sex\ only\ for\ identity\ term\r\n\ @term\ term\ to\ verified\ as\ identity\ term\r\n
comment64.params=
comment64.target=StringVector\ findFocalTerms()
comment64.text=\ Finds\ the\ focal\ terms\ for\ this\ map,\ if\ any\r\n\ our\ expectations\ is\ that\ there\ will\ be\ only\ one\ that\ is\ non-gendered,\r\n\ hence\ the\ same\ as\ an\ identity\ term,\r\n\ and\ two\ in\ some\ cases\ where\ gendered\ (as\ in\ Tribriand\ terminology)\r\n\ @return\ list\ of\ the\ <b>String</b>\ <i>names</i>\ of\ all\ focal\ terms.\r\n
comment65.params=
comment65.target=boolean\ checkTermsForMultipleProducts()
comment66.params=
comment66.target=boolean\ checkSimplicityOfStructure()
comment67.params=
comment67.target=boolean\ checkPrimaryStructure()
comment68.params=theMaster
comment68.target=void\ setTheMaster(VariablesFactory)
comment69.params=
comment69.target=VariablesFactory\ getTheMaster()
comment7.params=
comment7.target=boolean\ isNext()
comment70.params=term
comment70.target=boolean\ isEffectiveTerm(java.lang.String)
comment70.text=\ Checks\ if\ a\ kin\ term\ is\ an\ effective\ kin\ term.\r\n\ @param\ term\ is\ the\ term\ to\ be\ checked\r\n\ @return\ boolean\ flag\r\n
comment71.params=kinToGen\ gen\ term
comment71.target=java.lang.Integer\ theGeneration(java.util.Hashtable,\ TransferKinInfo,\ java.lang.String)
comment72.params=kinToGen\ term
comment72.target=void\ theGenerations(java.util.Hashtable,\ java.lang.String)
comment73.params=
comment73.target=java.util.Hashtable\ computeGenerations()
comment73.text=\ Checks\ the\ generation\ status\ of\ each\ kin\ term.\r\n\ @return\ hash\ table\ with\ terms\ as\ keys\ and\ generation\ status\ as\ entry\ in\ Integer\ form\r\n
comment74.params=newProd\ sv\ term
comment74.target=StringVector\ checkProducts(StringVector,\ StringVector,\ java.lang.String)
comment74.text=\ @return\ List\ of\ generator,\ term\ pairs\ where\ generator\ of\ term\ is\ not\ defined\ in\ the\ map.\r\n
comment75.params=
comment75.target=StringVector\ checkCompletenessOfStructure()
comment75.text=\ Checks\ map\ for\ completeness.\r\n\ @return\ List\ of\ generator,\ term\ pairs\ where\ generator\ of\ term\ is\ not\ defined\ in\ the\ map.\r\n
comment76.params=term
comment76.target=java.lang.String\ getSex(java.lang.String)
comment76.text=\ get\ sex\ of\ a\ kin\ terms\ in\ string\ form\r\n\ \ @term\ the\ term\r\n\ \ @return\ sex\ of\ the\ term\r\n
comment77.params=k1\ k2
comment77.target=boolean\ inArrowsSimilar(TransferKinInfo,\ TransferKinInfo)
comment78.params=t1\ t2
comment78.target=boolean\ areGeneratorsEquivalent(TransferKinInfo,\ TransferKinInfo)
comment79.params=
comment79.target=ListVector\ findStructuralSimilar()
comment79.text=\r\n\ \ \ \ public\ boolean\ mergeArrows(TransferKinInfo\ t1,\ TransferKinInfo\ t2)\ {\r\n\ \ \ \ if\ (\!areGeneratorsEquivalent(t1,t2))\ return\ false;\r\n\ \ \ \ if\ (t1.coveringTerm\ \!\=\ null)\ {\r\n\ \ \ \ if\ (t1.coveringTerm.equals(t2.coveringTerm))\ {\r\n\ \ \ \ TransferKinInfo\ tc\ \=\ lookupTerm(t1.coveringTerm);\r\n\ \ \ \ tc.orientation\ \=\ t1.orientation;\ //\ acting\ on\ structure\ tests\ in\ progress\r\n\ \ \ \ //\ may\ need\ to\ isolate\ to\ prevent\ mess\r\n\ \ \ \ return\ true;\r\n\ \ \ \ }\ else\ {\r\n\ \ \ \ System.out.println("mergeArrows\:\ t1.coveringTerm("+t1.coveringTerm+")\ different\ from\ t2.coveringTerm("+t2.coveringTerm+")");\r\n\ \ \ \ return\ false;\r\n\ \ \ \ }\r\n\ \ \ \ }\ else\ {\r\n\ \ \ \ if\ (t2.coveringTerm\ \!\=\ null)\ {\r\n\ \ \ \ System.out.println("mergeArrows\:\ t1.coveringTerm(null)\ different\ from\ t2.coveringTerm("+t2.coveringTerm+")");\r\n\ \ \ \ return\ false;\r\n\ \ \ \ }\r\n\ \ \ \ if\ (\!t1.outArrowsIdentical(t2))\ return\ false;\ //\ do\ not\ merge\r\n\ \ \ \ if\ (\!inArrowsSimilar(t1,\ t2))\ return\ false;\ //\ do\ not\ merge\r\n\r\n\ \ \ \ StringVector\ lv\=\ new\ StringVector();\r\n\ \ \ \ lv.add(t1.getTerm());\r\n\ \ \ \ lv.add(t2.getTerm());\r\n\ \ \ \ mergeTerms(lv,true);\r\n\ \ \ \ TransferKinInfo\ tc\ \=\ lookupTerm(t1.coveringTerm);\r\n\ \ \ \ tc.orientation\ \=\ t1.orientation;\r\n\ \ \ \ buildTable();\r\n\ \ \ \ buildInverseTable();\r\n\ \ \ \ lv\ \=\ findFocalTerms();\ //\ ---\ need\ to\ calc\ focal\ terms\r\n\ \ \ \ return\ true;\r\n\ \ \ \ }\r\n\ \ \ \ }\r\n\r\n\ \ \ \ public\ boolean\ mergeArrows()\ {\r\n\ \ \ \ boolean\ flag\ \=\ false;\r\n\ \ \ \ TransferKinInfoVector\ tv\ \=\ getEffectiveGenerators();\ //\ Effective\ generators??\r\n\ \ \ \ TransferKinInfoVector\ tx\ \=\ getEffectiveGenerators();\ //\ Effective\ generators??\r\n\ \ \ \ for(tv.reset();tv.isNext();)\ {\r\n\ \ \ \ TransferKinInfo\ t1\ \=\ tv.getNext();\r\n\ \ \ \ for(tx.reset();tx.isNext();)\ {\r\n\ \ \ \ TransferKinInfo\ t2\ \=\ tx.getNext();\r\n\ \ \ \ if\ (mergeArrows(t1,t2))\ flag\ \=\ true;\r\n\ \ \ \ }\r\n\ \ \ \ }\r\n\ \ \ \ return\ flag;\r\n\ \ \ \ }\r\n
comment8.params=
comment8.target=boolean\ isNextEffectiveTerm()
comment80.params=
comment80.target=boolean\ testMapForSpouseOfParentEquations()
comment80.text=\ Checks\ the\ map\ to\ see\ if\ equations\ of\ the\ form\ spouse\ of\ parent\ \=\ parent\r\n\ are\ valid\ in\ the\ kin\ term\ map.\r\n\ @return\ boolean\ flag\r\n
comment81.params=
comment81.target=boolean\ testMapForLinealDescendantRule()
comment81.text=\ Checks\ the\ map\ to\ see\ if\ equations\ of\ the\ form\ son\ \=\ daughter\ for\ descendant\ terms\r\n\ are\ valid\ in\ the\ kin\ term\ map.\ Only\ applies\ when\ there\ is\ neutral\ identity\ element.\r\n\ @return\ boolean\ flag\r\n
comment82.params=
comment82.target=boolean\ testMapForSiblingInLawEquations()
comment82.text=\ Checks\ the\ map\ to\ see\ if\ equations\ of\ the\ form\ sibling\ of\ spouse\ \=\ spouse\ of\ sibling\r\n\ are\ valid\ in\ the\ kin\ term\ map.\r\n\ @return\ boolean\ flag\r\n
comment83.params=
comment83.target=boolean\ testMapForParentOfChildInLawEquations()
comment83.text=\ Checks\ the\ map\ to\ see\ if\ equations\ of\ the\ form\ parent\ of\ child-in-law\ \=\ 0\r\n\ are\ valid\ in\ the\ kin\ term\ map.\r\n\ @return\ boolean\ flag\r\n
comment84.params=
comment84.target=boolean\ testMapForSingleChildProperty()
comment84.text=\ Checks\ the\ map\ to\ see\ if\ equations\ of\ the\ form\ son\ of\ FemaleSelf\ \=\ son\r\n\ \ or\ daughter\ of\ MaleSelf\ \=\ Daughter,\ where\ son\ of\ MaleSelf\ \=\ son\ and\r\n\ \ daughter\ of\ FemaleSelf\ \=\ daughter,\r\n\ are\ valid\ in\ the\ kin\ term\ map.\r\n\ @return\ boolean\ flag\r\n
comment85.params=
comment85.target=boolean\ testMapForAtomicSib()
comment85.text=\ Tests\ the\ map\ for\ atomic\ sib\ generators\r\n\ @return\ boolean\ flag\r\n
comment86.params=sex
comment86.target=boolean\ testMapForChildEquivalence(java.lang.String)
comment86.text=\ Checks\ the\ map\ to\ see\ if\ Son\ of\ Focal\ Term\ \=\ Daughter\ of\ Focal\ Term\r\n\ is\ valid\ in\ the\ kin\ term\ map.\r\n\ @param\ sex\ sex\ of\ focal\ term\r\n\ @return\ boolean\ flag\r\n
comment87.params=sex
comment87.target=boolean\ testMapForChildSibEquivalence(java.lang.String)
comment87.text=\ Checks\ the\ map\ to\ see\ if\ Son\ of\ Sibling\ of\ Focal\ Term\ \=\ Daughter\ of\ Sibling\ of\ Focal\ Term\r\n\ is\ valid\ in\ the\ kin\ term\ map\ where\ Sibling\ and\ Focal\ Term\ have\ opposite\ sex\r\n\ @param\ sex\ sex\ of\ focal\ term\r\n\ @return\ boolean\ flag\r\n
comment88.params=t1\ t2\ t3
comment88.target=StringVector\ termProduct(TransferKinInfoVector,\ TransferKinInfoVector,\ TransferKinInfoVector)
comment89.params=t1\ t2
comment89.target=StringVector\ termProduct(TransferKinInfoVector,\ TransferKinInfoVector)
comment9.params=k
comment9.target=TransferKinInfo\ effectiveTerm(TransferKinInfo)
numComments=90
